<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AOCode Round #6 Editorial</title>
      <link href="/post/aocr6-editorial/"/>
      <url>/post/aocr6-editorial/</url>
      
        <content type="html"><![CDATA[<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><a href="#table-of-contents">Table of Contents</a></li><li><a href="#a---bash-game-bg">$A$ - Bash Game (BG)</a><ul><li><a href="#%E6%A0%87%E9%A2%98%E7%9A%84%E7%90%86%E8%A7%A3">标题的理解</a></li><li><a href="#%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%E7%9A%84%E7%89%B9%E4%BE%8B">巴什博弈的特例</a></li><li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88">一般的巴什博弈</a></li><li><a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AC%E9%A2%98%E7%9A%84%E6%89%A9%E5%B1%95">对于本题的扩展</a></li></ul></li><li><a href="#c---flip-to-maximum-f2m">$C$ - Flip to Maximum (F2M)</a></li><li><a href="#d---tree-shadow-ts">$D$ - Tree Shadow (TS)</a><ul><li><a href="#%E5%9C%A8%E5%81%9A%E9%A2%98%E4%B9%8B%E5%89%8D%E7%9A%84%E5%8F%91%E7%8E%B0">在做题之前的发现</a></li><li><a href="#%E7%AE%80%E5%8D%95%E6%83%85%E5%86%B5--%E6%8E%A8%E5%85%AC%E5%BC%8F">简单情况 | 推公式</a></li><li><a href="#%E5%85%AC%E5%BC%8F%E7%9A%84%E5%8F%8D%E4%BE%8B">“公式”的反例</a></li><li><a href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%AC%E5%BC%8F">真正的公式</a></li></ul></li><li><a href="#e---array-counting-ac">$E$ - Array Counting (AC)</a></li><li><a href="#f---function-extreme-fex">$F$ - Function Extreme (FEx)</a></li></ul><h2 id="A-Bash-Game-BG"><a href="#A-Bash-Game-BG" class="headerlink" title="$A$ - Bash Game (BG)"></a>$A$ - Bash Game (BG)</h2><p><strong>这是本场比赛的第二签到题。</strong></p><p>如果你认真观看了题目中的视频，那么这题对于你<strong>一定是很简单的</strong>。</p><p><del>其实视频就是题解……</del></p><h3 id="标题的理解"><a href="#标题的理解" class="headerlink" title="标题的理解"></a>标题的理解</h3><p>标题 Bash Game，即巴什博弈，讲的是下面这样的一个博弈：</p><blockquote><p>有一堆 $n$ 个石子，两个人轮流取，一次最多取 $m$ 颗，谁先取完最后一颗谁赢。（更好的说法，直到谁不能取时谁就输了）</p></blockquote><p>这是一个公平组合游戏。由于这是签到题，本题解将不会具体描述 SG 函数 等<del>奇奇怪怪的</del>东西，有需要的读者可以上 <a href="http://oi-wiki.org/">OI Wiki</a> 自行查找。</p><h3 id="巴什博弈的特例"><a href="#巴什博弈的特例" class="headerlink" title="巴什博弈的特例"></a>巴什博弈的特例</h3><p>我们先不从一般的说起。先来举个栗子：现在 $n&#x3D;19,m&#x3D;5$，如果两个人都使用最优策略，谁会赢？</p><p>很明显先手必胜。先手只要拿 $1$ 个，以后如果对方拿 $a$ 个，先手就拿 $6-a$ 个，这样一定能先拿到最后一个。</p><p>给一个简易的示例：</p><table><thead><tr><th align="right">Who</th><th align="right">1</th><th align="right">2</th><th align="right">3</th><th align="right">4</th></tr></thead><tbody><tr><td align="right">先手</td><td align="right">1</td><td align="right">4</td><td align="right">3</td><td align="right">5</td></tr><tr><td align="right">后手</td><td align="right">2</td><td align="right">3</td><td align="right">1</td><td align="right"></td></tr><tr><td align="right">剩余</td><td align="right">16</td><td align="right">9</td><td align="right">5</td><td align="right">0</td></tr></tbody></table><p>扩展到一般的上面：</p><h3 id="一般的巴什博弈"><a href="#一般的巴什博弈" class="headerlink" title="一般的巴什博弈"></a>一般的巴什博弈</h3><p>下面的对于一般的巴什博弈的扩展：</p><blockquote><p>对于一场巴什博弈，有 $n$ 个石子，一次最多取 $m$ 颗，那么先手必胜，仅当 $n\not\equiv 0\pmod{m+1}$。</p><p>证明：</p><p>当 $n&#x3D;0$ 时，无石子，此时先手必输。<br>当 $n&#x3D;1,2,3,\cdots,m$ 时，先手只要拿一次即可取走所有石子，先手必胜。<br>当 $n&#x3D;m+1$ 时，先手无论取多少石子，都会将局面推到对方的 $n&#x3D;1,2,3,\cdots,m$ 的局面，此时先手必输。<br>……</p><p>以此类推，当 $n\equiv0\pmod{n+1}$ 时，先手必败；反之先手必胜。</p></blockquote><h3 id="对于本题的扩展"><a href="#对于本题的扩展" class="headerlink" title="对于本题的扩展"></a>对于本题的扩展</h3><p>对于本题，限制 $m$ 是可以改变的。</p><p>此时，我们的目标就是，在每一次取子后，都要保证轮到对方取子时，对方在当时限制下处于必败局面（即“后手必败”）。</p><p>若在限制 $m$ 下必败，则此时石子总数 $n$ 满足 $(m+1)|n$。</p><p>那么，我们只要选出一个限制，然后取走余数个石子即可。</p><p>重复以上操作，你就能通过本题了。</p><h2 id="C-Flip-to-Maximum-F2M"><a href="#C-Flip-to-Maximum-F2M" class="headerlink" title="$C$ - Flip to Maximum (F2M)"></a>$C$ - Flip to Maximum (F2M)</h2><p>这是<strong>本场比赛的签到题</strong>。做不出本题是不应该的。</p><p>容易发现，当 $x$ 末尾是 <code>1</code> 时，可以通过永远取 $[L,R]&#x3D;[x.size,x.size]$ 来任意修改 $s$。</p><p>扩展一下，只要取 $x$ 最后一个 <code>1</code> 及之后的所有 <code>0</code>（设为 $y$ 个）即可任意修改 $s$ 除了后 $y$ 位以外的所有字符。</p><p>于是题目便很简单。再简单判一下有无符号即可。注意不要忘了模 $1<del>224</del>845<del>820</del>132<del>755</del>647$。</p><h2 id="D-Tree-Shadow-TS"><a href="#D-Tree-Shadow-TS" class="headerlink" title="$D$ - Tree Shadow (TS)"></a>$D$ - Tree Shadow (TS)</h2><p>这是一道纯数学题。本题将会使用大量三角函数，请先自行了解三角函数的概念。</p><h3 id="在做题之前的发现"><a href="#在做题之前的发现" class="headerlink" title="在做题之前的发现"></a>在做题之前的发现</h3><p>在你开始打代码之前，先仔细阅读一下题面。你会发现，<strong>其实太阳光的不含最大角度（$\alpha$）即为所有道路中下坡幅度最大的角度。</strong> 当然还要转换一下。</p><p>那么，其实我们只要求 $x$ 就行了。怎么求呢？</p><h3 id="简单情况-推公式"><a href="#简单情况-推公式" class="headerlink" title="简单情况 | 推公式"></a>简单情况 | 推公式</h3><p>如图，当 $d_2&gt;0$ 时，将原来在斜坡上的影子映射到地平线上，得到 $newl_2&#x3D;l_2\cos d_2+l_2\sin d_2\cot\beta$，其中 $\beta&#x3D;\pi-\alpha$.</p><p><a href="https://imgse.com/i/pC4TcTI"><img src="https://s1.ax1x.com/2023/07/14/pC4TcTI.png" alt="pC4TcTI.png"></a></p><p>再如图，可以得到，当 $d_2&lt;0$ 时，以上式子仍然成立.</p><p><a href="https://imgse.com/i/pC4T60A"><img src="https://s1.ax1x.com/2023/07/14/pC4T60A.png" alt="pC4T60A.png"></a></p><p>当 $d_2&#x3D;0$ 时：</p><p>$$<br>\begin{split}<br>newl_2&amp;&#x3D;l_2\cos d_2+l_2\sin d_2\cot\beta\<br>      &amp;&#x3D;l_2\cdot 1+l_2\cdot 0\cdot\cot\beta\<br>      &amp;&#x3D;l_2<br>\end{split}<br>$$</p><p>所以，不论 $d_2$ 的大小，总有 $newl_2&#x3D;l_2\cos d_2+l_2\sin d_2\cot\beta~(\beta&#x3D;\pi-\alpha)$.</p><p>推导到所有 $d_i$，可求出：$newl_i&#x3D;l_i\cos d_i+l_i\sin d_i\cot\beta~(\beta&#x3D;\pi-\alpha)$.</p><p>那么就可以求出 $\displaystyle x&#x3D;\left(\sum_{i&#x3D;1}^{n}newl_i\right)\tan\beta~(\beta&#x3D;\pi-\alpha)$.</p><p>递推算出对于所有 $l_i$ 的 $newl_i$，累加后计算即可.</p><p>这个公式<strong>没有问题</strong>，但是只能获得 $70%$ 的分数。这是为什么呢？</p><h3 id="“公式”的反例"><a href="#“公式”的反例" class="headerlink" title="“公式”的反例"></a>“公式”的反例</h3><p>当没有 $d_i&lt;0$ 时，$\alpha&#x3D;\pi$，那么 $\beta&#x3D;0$，由于 $\tan 0&#x3D;0$，这样无论如何，最后求出的 $x$ 都是 $0$。而很明显，当有上坡路时，在地平线以上的道路当 $x&#x3D;0$ 时必然无法被照到。也就是说，这个“公式”是错的。</p><p>那么如何解决呢？能够发现，这个“公式”只在没有下坡路时失效，而没有下坡路时最小树高 $x$ 即为整条路上最高点的高度（假设地平线高度为 $0$）。于是只要特判一下就好了。</p><p>这样，就可以通过全部测试点，获得 $100$ 分。</p><p>不过，无论如何，这样的特判终究不能覆盖所有情况。能否有一种适用全部情况的公式呢？</p><h3 id="真正的公式"><a href="#真正的公式" class="headerlink" title="真正的公式"></a>真正的公式</h3><p>对于每段路 $i$，我们重定义 $newl_i$，新定义 $height_i$，$needx_i$：</p><ul><li>$newl_i$ 为这段路<strong>垂直</strong>映射到地面后的长度；</li><li>$height_i$ 为这段路<strong>右端点</strong>的高度；</li><li>$needx_i$ 为树影投射到这段路<strong>右端点</strong>所需的树的<strong>最小高度</strong>。</li></ul><p>通过一系列计算，我们可以得出：（同样的，$\beta&#x3D;\pi-\alpha$）</p><p>$$<br>\begin{split}<br>newl_i   &amp;&#x3D; l_i\cos d_i \<br>height_i &amp;&#x3D; height_{i-1}+l_i\sin d_i&#x3D;\sum_{j&#x3D;1}^{i}l_j\sin d_j \<br>needx_i  &amp;&#x3D; height_i+\left(\sum_{j&#x3D;1}^{i}newl_j\right)\tan\beta<br>\end{split}<br>$$</p><p>最后，再求出 $\displaystyle x&#x3D;\max_{i&#x3D;1}^{n}need_i$ 即可[^1]。</p><p><strong>这才是本题的正解。</strong> 它能够直接获得 $100$ 分，甚至还不必为 $\cot$ 的运算方法发愁。</p><p>[^1]: 注：其实求 $x$ 直接取 $need_n$ 即可。至于为什么，请自行思考。</p><h2 id="E-Array-Counting-AC"><a href="#E-Array-Counting-AC" class="headerlink" title="$E$ - Array Counting (AC)"></a>$E$ - Array Counting (AC)</h2><p>咕咕咕……</p><h2 id="F-Function-Extreme-FEx"><a href="#F-Function-Extreme-FEx" class="headerlink" title="$F$ - Function Extreme (FEx)"></a>$F$ - Function Extreme (FEx)</h2><p>又是一道数学题。<del>建议打个二三十分的模拟退火就走人。</del></p><p>题解先咕着。（主要是比较难写）</p>]]></content>
      
      
      <categories>
          
          <category> editorial </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOCode Round #5 Editorial</title>
      <link href="/post/aocr5-editorial/"/>
      <url>/post/aocr5-editorial/</url>
      
        <content type="html"><![CDATA[<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><a href="#table-of-contents">Table of Contents</a></li><li><a href="#a1-the-triangle-print">$A1$ The Triangle Print</a></li><li><a href="#a2-the-square-print">$A2$ The Square Print</a><ul><li><a href="#%E5%88%9D%E6%AD%A5%E8%A7%82%E5%AF%9F">初步观察</a></li><li><a href="#%E6%8E%A8%E5%BC%8F%E5%AD%90">推式子</a></li></ul></li><li><a href="#c-powers-2">$C$ Powers 2</a></li><li><a href="#e-dates-or-no-dates">$E$ Dates or No Dates?</a><ul><li><a href="#%E8%A7%A3%E6%B3%95">解法</a></li></ul></li><li><a href="#f-date-number">$F$ Date Number</a><ul><li><a href="#%E8%A7%A3%E6%B3%95-1">解法</a></li></ul></li><li><a href="#g-index-equation">$G$ Index Equation</a><ul><li><a href="#%E9%A2%98%E6%84%8F%E8%A7%A3%E9%87%8A">题意解释</a></li><li><a href="#%E8%A7%A3%E6%B3%95-2">解法</a></li></ul></li><li><a href="#h-coding-for-codes">$H$ Coding for Codes</a><ul><li><a href="#std-%E5%81%9A%E6%B3%95"><code>std</code> 做法</a></li><li><a href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95">可能的另一种做法</a></li></ul></li><li><a href="#i-new-operation-defined">$I$ New Operation Defined</a><ul><li><a href="#fx-%E7%BB%93%E6%9E%9C%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7">$f(x)$ 结果的唯一性</a></li><li><a href="#fx-%E7%BB%93%E6%9E%9C%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F">$f(x)$ 结果的一般形式</a><ul><li><a href="#3-%E4%B8%AA%E8%B4%A8%E5%9B%A0%E6%95%B0">$3$ 个质因数</a></li><li><a href="#4-%E4%B8%AA%E8%B4%A8%E5%9B%A0%E6%95%B0">$4$ 个质因数</a></li><li><a href="#%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F">最后的一般形式</a></li></ul></li><li><a href="#%E8%A7%A3%E6%B3%95-3">解法</a></li></ul></li><li><a href="#ex-equation-solver">$Ex$ Equation Solver</a></li></ul><h2 id="A1-The-Triangle-Print"><a href="#A1-The-Triangle-Print" class="headerlink" title="$A1$ The Triangle Print"></a>$A1$ The Triangle Print</h2><p>$A1$ 过于简单，被 zxx 等 <code>dalao</code> 无限吐槽，你看看，这题是有多水。</p><h2 id="A2-The-Square-Print"><a href="#A2-The-Square-Print" class="headerlink" title="$A2$ The Square Print"></a>$A2$ The Square Print</h2><p>对于此题的难度，zxx 与 AOCR#5 出题人们 有很大的分歧。。。</p><p>本题与 $A1$ 一样，也是图形打印，但是稍微难一点。</p><h3 id="初步观察"><a href="#初步观察" class="headerlink" title="初步观察"></a>初步观察</h3><p>让我们看一下样例。</p><pre><code class="plain">(0)+(1)+-+| |+-+(2)+-+--+-+| |  | |+-+  +-+|      |+-+  +-+| |  | |+-+--+-+(3)+-+--+-+----+-+--+-+| |  | |    | |  | |+-+  +-+    +-+  +-+|      |    |      ||      |    |      |+-+  +-+    +-+  +-+| |  | |    | |  | |+-+--+-+    +-+--+-+|                  ||                  ||                  ||                  |+-+--+-+    +-+--+-+| |  | |    | |  | |+-+  +-+    +-+  +-+|      |    |      ||      |    |      |+-+  +-+    +-+  +-+| |  | |    | |  | |+-+--+-+----+-+--+-+</code></pre><p>能够看出，对于第 $i$ 幅图，它的四个角上为第 $i-1$ 幅图，并在边上用 $2^{i-1}$ 个 <code>-</code> 或 <code>|</code> 连接。</p><p>这样，我们便能输入 $n$ 后，预处理递推出第 $i$ 幅图的边长（$i\in[1,n]\land i\in\Bbb{Z}$）。那么也就可以（当 $n&lt;10$ 时）递归画图了。</p><p>但是此时只能接受 $1\le n\le 10^5$ 的数据范围，也就是说，只能通过前 $12$ 个测试点，获得 $34$ 分的“好成绩”。要怎么使程序接受 $1\le n \le 10^9$，甚至 $1\le n\le 10^{18}$ 的数据范围呢？</p><p>左思右想，只有推式子了。</p><h3 id="推式子"><a href="#推式子" class="headerlink" title="推式子"></a>推式子</h3><p>定义 $f(n)$ 为第 $n$ 个正方形的边长，则有 $f(0)&#x3D;1,f(n)&#x3D;2f(n-1)+2^{n-1}$。</p><p>那么有：</p><p>$$\begin{split}<br>f(n)&amp;&#x3D;2f(n-1)+2^{n-1}\<br>    &amp;&#x3D;2(2f(n-2)+2^{n-2})+2^{n-1}\<br>    &amp;&#x3D;2(2(2f(n-3)+2^{n-3})+2^{n-2})+2^{n-1}\<br>    &amp;&#x3D;\cdots\<br>    &amp;&#x3D;\underbrace{2(2(2(\cdots2(2(2}<em>{n}(1)+\underbrace{2^0)+2^1)\cdots)+2^{n-3})+2^{n-2})+2^{n-1}}</em>{n}\<br>    &amp;&#x3D;2^n+\underbrace{2^{n-1}\cdot2^0+2^{n-2}\cdot2^1+\cdots+2^2\cdot2^{n-3}+2^{1}\cdot2^{n-2}+2^{n-1}}_{n}\<br>    &amp;&#x3D;2^n+n\cdot2^{n-1}<br>\end{split}$$</p><p>这样，一个简单的快速幂就搞定了！</p><p>能够接受 $1\le n\le 10^{18}$ 的数据范围，获得 $100$ 分！</p><p>上代码：（<code>std</code> 总用时约 $80ms$ — $20$ test cases）</p><pre><code class="cpp">#include &lt;cstdio&gt;#include &lt;cctype&gt; // isdigit#include &lt;cstring&gt; // memsetusing namespace std;#define div2(n) ((n)&gt;&gt;1)#define int long longconst int mod=998244353;int bpow(int x, int e) &#123;    if(e==0) return 1;    if(e==1) return x;    int res=bpow(x,div2(e));    res=res*res%mod;    if(e&amp;1) res=res*x%mod;    return res;&#125;int f(int x) &#123; return (bpow(2,x)+x%mod*bpow(2,x-1)%mod)%mod; &#125;char mp[3005][3005];void generate(int sx, int sy, int glen, int plen) &#123;    if(plen==1) &#123;        mp[sx][sy] = mp[sx][sy+2] = mp[sx+2][sy] = mp[sx+2][sy+2] = &#39;+&#39;;        mp[sx][sy+1] = mp[sx+2][sy+1] = &#39;-&#39;;        mp[sx+1][sy] = mp[sx+1][sy+2] = &#39;|&#39;;        return;    &#125;    generate(sx, sy,             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,             plen-1);    generate(sx+f(plen-1)+bpow(2,plen-1), sy,             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,             plen-1);    generate(sx, sy+f(plen-1)+bpow(2,plen-1),             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,             plen-1);    generate(sx+f(plen-1)+bpow(2,plen-1), sy+f(plen-1)+bpow(2,plen-1),             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,             plen-1);    for(int i = f(plen-1); i &lt; f(plen-1) + bpow(2,plen-1); ++i)&#123;        mp[sx][sy+i] = mp[sx+glen-1][sy+i] = &#39;-&#39;;        mp[sx+i][sy] = mp[sx+i][sy+glen-1] = &#39;|&#39;;    &#125;&#125;inline int read() &#123;    int res=0;    char c=getchar();    while(!isdigit(c)) c=getchar();    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();    return res;&#125;char __buf[5000000];signed main() &#123;    int n=read();    setvbuf(stdout, __buf, _IOFBF, sizeof __buf);    if(!n) return printf(&quot;1\n+\n&quot;), 0;    printf(&quot;%lld\n&quot;, f(n));    if(n&lt;=9 /* 1*2^9+9*2^8=2816 */) &#123;        int l=f(n);        for(int i=0; i&lt;l; ++i)            for(int j=0; j&lt;l; ++j) mp[i][j]=&#39; &#39;;        generate(0, 0, l, n); // generate!        for(int i=0; i&lt;l; ++i) &#123;            for(int j=0; j&lt;l; ++j)                putchar(mp[i][j]);            putchar(&#39;\n&#39;);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="C-Powers-2"><a href="#C-Powers-2" class="headerlink" title="$C$ Powers 2"></a>$C$ Powers 2</h2><p>此题为 AOCR #5 签到题。</p><p>具体详见 <a href="http://oj.oimaster.cf/problem/14">KYCode Round #6 B - Powers</a>。</p><p><del>特别鸣谢：piggy123</del></p><p><a href="http://oj.oimaster.cf/submission/374">上代码：（<code>std</code> 总用时约 $35ms$ — $20$ test cases）</a></p><h2 id="E-Dates-or-No-Dates"><a href="#E-Dates-or-No-Dates" class="headerlink" title="$E$ Dates or No Dates?"></a>$E$ Dates or No Dates?</h2><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>离散化+差分。</p><p>首先将 $L_i&#x2F;R_i&#x2F;l_i&#x2F;r_i$ 合并后进行离散化处理。（注意，一定要合并！）</p><p>接着开两个差分数组 <code>c1</code> 和 <code>c2</code>，一个存 $L_i&#x2F;R_i$，一个存 $l_i&#x2F;r_i$。</p><p>$L_i&#x2F;R_i$ 直接对应存：<code>++c1[L[i]],--c1[R[i]]</code>；</p><p>$l_i&#x2F;r_i$ 则比较复杂：</p><ul><li><code>forall i in [0,m): ++c2[r[i]],--c2[l[i+1]]</code>；</li><li><code>++c2[r[m]]</code>。</li></ul><p>如此，然后遍历整个数组，计算即可。</p><p>上代码：（<code>std</code> 总用时约 $350ms$ — $20$ test cases）</p><pre><code class="cpp">#include &lt;cstdio&gt;#include &lt;cctype&gt; // isdigit#include &lt;algorithm&gt;using namespace std;int n, m, len, res = 0;int L[100005], R[100005];int l[100005], r[100005];int allnum[400020];int c1[400020], c2[400020], sum1, sum2, tmc;inline int read() &#123;    int res=0; // no negative values    char c=getchar();    while(!isdigit(c)) c=getchar();    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();    return res;&#125;char __buf[5000000];signed main() &#123;    setvbuf(stdout, __buf, _IOFBF, sizeof __buf);    n=read();    for(int i = 1; i &lt;= n; ++i) &#123;        L[i]=read(), R[i]=read();        allnum[i*2-1] = L[i];        allnum[i*2] = R[i];    &#125;    m=read();    for(int i = 1; i &lt;= m; ++i) &#123;        l[i]=read(), r[i]=read();        allnum[n*2+i*2-1] = l[i];        allnum[n*2+i*2] = r[i];    &#125;    sort(allnum+1, allnum+n*2+m*2+1);    len = unique(allnum+1, allnum+n*2+m*2+1)-allnum-1;    for(int i = 1; i &lt;= n; ++i) &#123;        L[i] = lower_bound(allnum+1, allnum+len+1, L[i])-allnum;        R[i] = lower_bound(allnum+1, allnum+len+1, R[i])-allnum;        ++c1[L[i]];        --c1[R[i]];    &#125;    ++c2[0];    for(int i = 1; i &lt;= m; ++i) &#123;        l[i] = lower_bound(allnum+1, allnum+len+1, l[i])-allnum;        r[i] = lower_bound(allnum+1, allnum+len+1, r[i])-allnum;        --c2[l[i]];        ++c2[r[i]];    &#125;    --c2[len];    sum1=sum2=tmc=0;    for(int i = 0; i &lt;= len; ++i) &#123;        sum1+=c1[i];        sum2+=c2[i];        if(sum1 &amp;&amp; sum2) &#123;            tmc += (allnum[i+1]-allnum[i]);        &#125; else &#123;            res = max(res, tmc);            tmc = 0;        &#125;    &#125;    printf(&quot;%d\n&quot;, res);    return 0;&#125;</code></pre><h2 id="F-Date-Number"><a href="#F-Date-Number" class="headerlink" title="$F$ Date Number"></a>$F$ Date Number</h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>Trie 半模板题。（或者：01Trie，zxx 说这不是 Trie？）</p><p>Trie 是一棵字典树，在这棵树上可以方便地判断前缀和。</p><p>对于本题，我们可以把整数看做是一个二进制串，把这个串像字符串一样插入 Trie。</p><p>这时，Trie 类似一个二叉树，一个节点只有两个子节点，通向它们的边分别是 <code>0</code> 和 <code>1</code>。</p><p>为了不重复地查询，我们可以在插入一个数前先查询目前这个数与其他数 $\oplus(\operatorname{xor})$ 的最大值。</p><p>如何查询？</p><ul><li>首先，将数插入 Trie 时，我们规定：从高位到低位依次插入（即，二进制串高位在前）；</li><li>然后，查询时，从最高位开始：<ul><li><code>(1)</code> 如果在这一位上，有与当前位不同的一条边（即此边上的 $0&#x2F;1$ 值 $\oplus$ 当前位后为 $1$），选择这条边，跳至 <code>(3)</code>；否则继续至 <code>(2)</code>。</li><li><code>(2)</code> 选择与当前位相同的边，然后跳至 <code>(3)</code>。</li><li><code>(3)</code> 进入下一位的查询，跳至 <code>(1)</code>。若已是最后一位，则退出，返回一路上所有边连起来后的值。</li></ul></li></ul><p>这样，一边读入，答案就出来了。时间复杂度 $\mathcal{O}(n\log2^{32})&#x3D;\mathcal{O}(32n)$。</p><p>上代码：（<code>std</code> 总用时约 $1100ms$ — $20$ test cases）</p><pre><code class="cpp">#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;utility&gt;#include &lt;tuple&gt;using namespace std;using uint = unsigned;#define int uintint n, q, a[100005];int tot, trie[100005&lt;&lt;5][2];void trie_init() &#123;    memset(trie, 0, sizeof trie);    tot=1;&#125;void trie_ins(int p) &#123;    int rt = 1;    for(int i=(1&lt;&lt;31); i&gt;0; i&gt;&gt;=1) &#123;        int q = (p&amp;i)?1:0;        if(trie[rt][q]==0) trie[rt][q]=++tot;        rt = trie[rt][q];    &#125;&#125;pair&lt;int,int&gt; trie_qry(int x) &#123;    int rt=1, ans1=0, ans2=0;    for(int i=(1&lt;&lt;31); i&gt;0; i&gt;&gt;=1) &#123;        int q = (x&amp;i)?1:0;        if(trie[rt][q^1]) &#123;            ans1 = ans1&lt;&lt;1|(q^1);            ans2 = ans2&lt;&lt;1|1;            rt = trie[rt][q^1];        &#125; else &#123;            ans1 = ans1&lt;&lt;1|q;            ans2 = ans2&lt;&lt;1;            rt = trie[rt][q];        &#125;    &#125;    return &#123;ans1,ans2&#125;;&#125;char __buf[5000000];signed main() &#123;    setvbuf(stdout, __buf, _IOFBF, sizeof __buf);    scanf(&quot;%u&quot;, &amp;n);    trie_init();    for(int i = 0; i &lt; n; ++i) &#123;        scanf(&quot;%u&quot;, a+i);        trie_ins(a[i]);    &#125;    scanf(&quot;%u&quot;, &amp;q);    while(q--) &#123;        int x;        scanf(&quot;%u&quot;, &amp;x);        int a, b;        tie(a,b) = trie_qry(x);        printf(&quot;%u %u\n&quot;, a, b);    &#125;    return 0;&#125;</code></pre><h2 id="G-Index-Equation"><a href="#G-Index-Equation" class="headerlink" title="$G$ Index Equation"></a>$G$ Index Equation</h2><h3 id="题意解释"><a href="#题意解释" class="headerlink" title="题意解释"></a>题意解释</h3><p>这题大家读题应该很困难吧。。。为了安慰大家脆弱的心灵，这里给出题意解释。</p><blockquote><p>对于任意两个整数 $x$、$y$（$x&gt;y$），一定能够找出一个<strong>实数</strong> $d$，使得 $(x)<em>{10}&#x3D;(y)</em>{d}$（即 $10$ 进制下的 $x$ 等于 $d$ 进制下的 $y$）。给出 $x$、$y$，找出这个<strong>实数</strong> $d$，保留 $4$ 位小数。</p></blockquote><p>注意，上面明确说明 <strong>$d$ 是实数</strong>！也就是说，$d$ 不一定是整数。<strong>也就是说，本题不能进行枚举。</strong></p><p>不枚举怎么办？</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>题目中说明 $x$、$y$ 不超过 $4$ 位。让我们推一推式子：</p><p>设 $x&#x3D;\overline{a_1a_2a_3a_4}$，$y&#x3D;\overline{b_1b_2b_3b_4}$。</p><p>那么根据进制的定义，有 $10^3a_1+10^2a_2+10a_3+a_4&#x3D;d^3b_1+d^2b_2+db_3+b_4$。</p><p>整理一下，得 $b_1d^3+b_2d^2+b_3d&#x3D;x-b_4$。</p><p>那么问题就成了求这个关于 $d$ 的方程的一个<strong>正实数</strong>解。（进制默认为正数）</p><p><del>对于任何一元 $n$ 次方程，未知数在第一象限上都是单调的。</del>（左边的话十分错误）</p><p>对于任何 $n\ge 1$ 的指数函数，函数在第一象限全部单调上升。故它们的和函数也在第一象限单调上升，值具有单调性，二分正确。</p><p>那么二分 $d$ 就行了。<strong>注意精度。</strong></p><p>时间复杂度：$\mathcal{O}(\log x)$。</p><p>上代码：（<code>std</code> 总用时约 $30ms$ — $20$ test cases）</p><pre><code class="cpp">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;const double eps = 1e-6;int x, y;int yy[10], len;void inityy() &#123;    yy[1] = y / 1000;    yy[2] = y / 100 % 10;    yy[3] = y / 10 % 10;    yy[4] = y % 10;&#125;double f(double x) &#123;    return 1.0*yy[1]*x*x*x + 1.0*yy[2]*x*x + 1.0*yy[3]*x + 1.0*yy[4];&#125;inline int read() &#123;    int res=0;    char c=getchar();    while(!isdigit(c)) c=getchar();    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();    return res;&#125;signed main() &#123;    x=read(),y=read();    if(y&lt;10) printf(&quot;-1\n&quot;);    else &#123;        inityy();        double l = 0.0, r = max(x, y);        while(fabs(l-r)&gt;eps) &#123;            double mid = (l+r)/2.0;            double p = f(mid);            if(p-x&gt;eps) r = mid;            else l = mid;        &#125;        printf(&quot;%.5f\n&quot;, l);    &#125;    return 0;&#125;</code></pre><h2 id="H-Coding-for-Codes"><a href="#H-Coding-for-Codes" class="headerlink" title="$H$ Coding for Codes"></a>$H$ Coding for Codes</h2><p>本题应有两种做法。由于<del>时间</del>技术原因，这里仅讲解一种做法。</p><h3 id="std-做法"><a href="#std-做法" class="headerlink" title="std 做法"></a><code>std</code> 做法</h3><p>由题目我们可以发现，在本题中，$x$ 越小，$g$ 越大；$x$ 越大，$g$ 越小。因此，$x$ 满足单调性。</p><p>那么，既然要求 $x$ 的个数，就可以求出 $x$ 的最小值 $x_{max}$ 和最大值 $x_{min}$，然后输出 $x_{max}-x_{min}+1$ 即可。</p><p>至于 $x_{min}$ 和 $x_{max}$，既然 $x$ 单调，就可以用二分解答。</p><p>时间复杂度 $\mathcal{O}(t\log x)$。</p><p>上代码：（<code>std</code> 总用时约 $40ms$ — $10$ test cases）</p><pre><code class="cpp">#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;#define div2(n) ((n)&gt;&gt;1)long long t;long long a, b, c, g;long long check(long long p) &#123;    for(long long i = 0; i &lt; g; ++i) &#123;        if(p&gt;c) return i;        p=p*a+b;    &#125;    if(p&gt;c) return g;    return p;&#125;inline long long read() &#123;    long long res=0;    char c=getchar();    while(!isdigit(c)) c=getchar();    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();    return res;&#125;signed main() &#123;    t=read();    while(t--) &#123;        a=read(),b=read(),c=read(),g=read();        long long ansl, ansr;        if(g==0) &#123;            printf(&quot;%llu\n&quot;, (unsigned long long)(-1)-(unsigned long long)c);            continue;        &#125;        // CHECK MINIMUM        long long l=0, r=c, x;        while(l&lt;r) &#123;            x = div2(l+r);            long long f = check(x);            if(f&lt;=g) r = x;            else l = x+1;        &#125;        ansl = r;        if(check(ansl)!=g) &#123;            printf(&quot;0\n&quot;);            continue;        &#125;        // CHECK MAXIMUM        l=0, r=c;        while(l&lt;r) &#123;            x = div2(l+r+1);            long long f = check(x);            if(f&lt;g) r = x-1;            else l = x;        &#125;        ansr = l;        if(check(ansr)!=g) &#123;            printf(&quot;0\n&quot;);            continue;        &#125;        printf(&quot;%lld\n&quot;, ansr-ansl+1);    &#125;    return 0;&#125;</code></pre><h3 id="可能的另一种做法"><a href="#可能的另一种做法" class="headerlink" title="可能的另一种做法"></a>可能的另一种做法</h3><p>既然 $g$ 已知，那么就可以用已知的 $g$，倒推出 $x_{max}$ 和 $x_{min}$，然后计算即可。</p><p>这可能是选手的第一想法。</p><p>Authors 因时间原因，没有深入思考这个问题，但是，我们认为这个方法有以下几个特点：</p><ul><li>复杂。倒推因为有除法，式子很难推，推的过程很复杂；即使推出来，式子也有可能很复杂。</li><li>但是，这个方法一定（Authors 预测）比 <code>std</code> 做法快（即使是常数上的）。</li></ul><h2 id="I-New-Operation-Defined"><a href="#I-New-Operation-Defined" class="headerlink" title="$I$ New Operation Defined"></a>$I$ New Operation Defined</h2><h3 id="f-x-结果的唯一性"><a href="#f-x-结果的唯一性" class="headerlink" title="$f(x)$ 结果的唯一性"></a>$f(x)$ 结果的唯一性</h3><p>让我们先回顾一下题目中 $f(…)$ 的定义。</p><ul><li>若 $x$ 是质数，则 $f(x)&#x3D;1$；</li><li>若有两个大于 $1$ 的整数 $a,b$，则 $f(ab)&#x3D;bf(a)+af(b)$。</li></ul><p>有人会疑惑：这样对于同一个 $f(x)$，不同计算方法是不是结果就不一样呢？其实不然。</p><p>假设 $x&#x3D;30$，则 $f(x)&#x3D;f(30)$ 有以下几种计算方法，仔细思考一下会发现是一样的：</p><p>$$\begin{split}<br>(1):f(30)&amp;&#x3D;f(2\times15)\<br>         &amp;&#x3D;15f(2)+2f(15)\<br>         &amp;&#x3D;15+2f(3\times5)\<br>         &amp;&#x3D;15+2(5f(3)+3f(5))\<br>         &amp;&#x3D;15+2(5+3)\<br>         &amp;&#x3D;15+2\times8\<br>         &amp;&#x3D;15+16\<br>         &amp;&#x3D;31\<br>(2):f(30)&amp;&#x3D;f(3\times10)\<br>         &amp;&#x3D;10f(3)+3f(10)\<br>         &amp;&#x3D;10+3f(\times5)\<br>         &amp;&#x3D;10+3(5f(2)+2f(5))\<br>         &amp;&#x3D;10+3(5+2)\<br>         &amp;&#x3D;10+3\times7\<br>         &amp;&#x3D;10+21\<br>         &amp;&#x3D;31\<br>(3):f(30)&amp;&#x3D;f(5\times6)\<br>         &amp;&#x3D;6f(5)+5f(6)\<br>         &amp;&#x3D;6+5f(2\times3)\<br>         &amp;&#x3D;6+5(3f(2)+2f(3))\<br>         &amp;&#x3D;6+5(3+2)\<br>         &amp;&#x3D;6+5\times5\<br>         &amp;&#x3D;6+25\<br>         &amp;&#x3D;31<br>\end{split}$$</p><p>如上，我们能够发现无论怎么计算，结果都一样。</p><p>并且我们发现，$f(x)$ 的结果只与 $x$ 的约数有关，那么就可以枚举 $x$ 的所有约数，向下递归得出答案。</p><p>这是一个可行方案，时间复杂度 $\mathcal{O}(kn^2)$。（$k$ 是一次高精乘&#x2F;除法的复杂度）</p><h3 id="f-x-结果的一般形式"><a href="#f-x-结果的一般形式" class="headerlink" title="$f(x)$ 结果的一般形式"></a>$f(x)$ 结果的一般形式</h3><p>上面所说的可行方案明显无法通过时间限制，因为 $1\le n\le 2000$，而 $k$ 又能达到 $6000$ 级别，$\mathcal{O}(kn^2)&#x3D;\mathcal{O}(2.4\times10^{10})$，无法承受。</p><p>那么就得找出更简便的算法了。我们试着推出 $f(x)$ 的一般形式。</p><p>题目给出的是质因数分解，那我们就从质因数下手。</p><p>先从 $3$ 个质因数下手。</p><h4 id="3-个质因数"><a href="#3-个质因数" class="headerlink" title="$3$ 个质因数"></a>$3$ 个质因数</h4><p>设 $x&#x3D;a\times b\times c$，其中 ${a,b,c}$ 是质数。</p><p>那么</p><p>$$\begin{split}<br>f(x)&amp;&#x3D;bcf(a)+af(bc)\<br>    &amp;&#x3D;bc+a(cf(b)+bf(c))\<br>    &amp;&#x3D;bc+a(c+b)\<br>    &amp;&#x3D;ab+ac+bc<br>\end{split}$$</p><p>如果指数不止 $1$ 次？</p><p>设 $x&#x3D;a^e\times b^p\times c^g$，其中 ${a,b,c}$ 是质数，${e,p,g}\in\Bbb{Z}^+$。</p><p>那么</p><p>$$\begin{split}<br>f(x)&amp;&#x3D;f\left(\underbrace{a\times a\times\cdots\times a}<em>{e}\times\underbrace{b\times b\times\cdots\times b}</em>{p}\times \underbrace{c\times c\times\cdots\times c}<em>{g}\right)\<br>    &amp;&#x3D;a^{e-1}b^pc^gf(a)+af\left(\underbrace{a\times a\times\cdots\times a}</em>{e-1}\times\underbrace{b\times b\times\cdots\times b}<em>{p}\times \underbrace{c\times c\times\cdots\times c}</em>{g}\right)\<br>    &amp;&#x3D;\cdots\<br>    &amp;&#x3D;e\times a^{e-1}b^pc^gf(a)+p\times a^eb^{p-1}c^gf(b)+g\times a^eb^pc^{g-1}f(c)\<br>    &amp;&#x3D;ea^{e-1}b^pc^g+pa^eb^{p-1}c^g+ga^eb^pc^{g-1}<br>\end{split}$$</p><p>$4$ 个质因数呢？</p><h4 id="4-个质因数"><a href="#4-个质因数" class="headerlink" title="$4$ 个质因数"></a>$4$ 个质因数</h4><p>设 $x&#x3D;a\times b\times c\times d$，其中 $a,b,c,d$ 是质数。</p><p>那么（过程略）</p><p>$$\begin{split}<br>f(x)&amp;&#x3D;\cdots\<br>    &amp;&#x3D;bcdf(a)+acdf(b)+abdf(c)+abcf(d)\<br>    &amp;&#x3D;abc+abc+acd+bcd<br>\end{split}$$</p><p>指数 $&gt;1$ 的情况这里就不枚举了。。。（累死人）</p><h4 id="最后的一般形式"><a href="#最后的一般形式" class="headerlink" title="最后的一般形式"></a>最后的一般形式</h4><p>设 $x&#x3D;p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times\cdots\times p_m^{a_m}$，其中 ${p_1,p_2,p_3,\cdots,p_m}$ 都是质数，${a_1,a_2,a_3,\cdots,a_m}\in\Bbb{Z}^+$。</p><p>那么</p><p>$$\begin{split}<br>f(x)&amp;&#x3D;\cdots\<br>    &amp;&#x3D;\sum^{m}<em>{i&#x3D;1}\left[a_i\times\left(\prod^{i-1}</em>{j&#x3D;1}p_j^{a_j}\right)\times p_i^{a_i-1}\times\left(\prod^{m}<em>{j&#x3D;i+1}p_j^{a_j}\right)\right]\<br>    &amp;&#x3D;\sum^{m}</em>{i&#x3D;1}\left(a_i\cdot\frac{x}{p_i}\right)<br>\end{split}$$</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>由于题目中直接给出质因数分解式，我们省去了分解质因数的时间。</p><p>那么，根据上面的公式，我们有一种简单做法：（<code>python</code>）</p><pre><code class="python">n = int(input())res = input()a = [int(n) for n in res.split()]mul = 1for i in range(n):    mul = mul*a[i]res = 0for i in range(n):    res += (mul//a[i])print(res)</code></pre><p><del>（没错第一个过这题的 <code>std</code> 是 <code>python</code> 写的嘿嘿嘿但你们过不去）</del></p><p>那么 <code>C++</code> 程序也很简单，本题的 <code>Author</code> nfls_old_salty_fish 只写了约 $30$ 行：</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;//#include &lt;windows.h&gt;using namespace std;typedef int czy;typedef long long xtk;typedef double zly;xtk p[6005],t[6005],a[6005],s[6005],n,ans[6005];int main()&#123;    //freopen(&quot;10.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;10.out&quot;,&quot;w&quot;,stdout);    xtk n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];    p[1]=1;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=6000;j++)p[j]*=a[i];        for(int j=1;j&lt;=6000;j++)p[j+1]+=p[j]/10,p[j]%=10;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=6000;j++)t[j]=p[j];        for(int j=6000;j&gt;0;j--)s[j]=t[j]/a[i],t[j]%=a[i],t[j-1]+=t[j]*10;        for(int j=1;j&lt;=6000;j++)ans[j]+=s[j],ans[j+1]+=ans[j]/10,ans[j]%=10;    &#125;    bool f=0;    for(int i=6000;i&gt;0;i--)&#123;        if(ans[i])f=1;        if(ans[i]||f)cout&lt;&lt;ans[i];    &#125;    return 0;&#125;</code></pre><h2 id="Ex-Equation-Solver"><a href="#Ex-Equation-Solver" class="headerlink" title="$Ex$ Equation Solver"></a>$Ex$ Equation Solver</h2><p>咕咕咕………………………………</p>]]></content>
      
      
      <categories>
          
          <category> editorial </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OI 名言</title>
      <link href="/post/well-known-OI-sayings/"/>
      <url>/post/well-known-OI-sayings/</url>
      
        <content type="html"><![CDATA[<h2 id="《OI-子》三章"><a href="#《OI-子》三章" class="headerlink" title="《OI 子》三章"></a>《OI 子》三章</h2><blockquote><p>《骗分榜一，暴力爆零》by 20210732ktq<br>正解不如暴力，暴力不如骗分。一道题目，两种做法，想而编之而WA。夫想而编之，必有得正解者矣，然而WA者，是正解不如暴力也。手非不酸也，码非不短也，部分分非不多也，暴力非不正确也，排名第二，是暴力不如骗分也。故曰，AC不以思路之深，暴力不以代码之短，首杀不以手速之快。骗分者榜一，暴力者爆零。爆零之至，老师骂之。榜一之至，全球膜之。以全球之所膜，攻教练之所骂，故OIer有不战，战必AK。</p></blockquote><blockquote><p>《水题不能淫》by 20210927chr<br>chr曰：“ktq，xcx岂不诚奆佬哉？骗分而OIers惧，正解而OI熄。”<br>xrz曰：“是焉得为奆佬乎？子未学OI乎？奆佬之冠也，zc命之，蒟蒻之冠也，ls命之，往送之CSP，戒之曰：‘往之CSP，必敬必戒，无违考规！’以骗为正者，蒟蒻之道也。做天下之难题，写天下之正解，AK天下之比赛。AK，与OIers由之；不AK，自己切题。水题不能淫，难题不能移，毒瘤不能屈，此之谓奆佬。”</p></blockquote><blockquote><p>《生于练习，死于退费》by 20211202lxy<br>轩发于范赵之中，Sai_t举于richup之间，澜译举于冰火之中，孔韬棋举于gen，项承煦举于florr，蒋亦霖举于ma，故天将降大任于是人也，必先苦其射飞，劳其破产，饿其王塔，空乏连击，行拂乱其所为，使其停止退费，曾益其所不会。<br>人恒错，然后能改；减于空，缩于时，而后过；骗于分，暴于力，而后涨。入则无暴力骗分，出则无AC过题者，人恒寄。然后知生于练习而死于退费也。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P1131 题解</title>
      <link href="/post/luogu-p1131-editorial/"/>
      <url>/post/luogu-p1131-editorial/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.luogu.com.cn/problem/P1131">传送门</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵 $n$ 个节点的以 $s$ 为根的树。每条树边都有一个长度。每次操作可以把一条树边的长度加 $1$。</p><p>问：至少操作多少次，可以使根节点到每个叶子节点的距离相等。</p><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论 $1$"></a>结论 $1$</h2><p>对于任意子树，其根节点到其每个叶子节点的距离相等。</p><blockquote><p><strong>证明</strong>：<br>反证法。<br>设对于根为 $R$ 的树的根为 $r$ 的某一子树，有两个叶子 $a$、$b$ 到 $r$ 的距离不等。<br>那么不妨设节点 $x$ 与 $y$ 间的距离为 $dis(x,y)$，则有<br>$$dis(a,r)\not&#x3D;dis(b,r)$$<br>所以<br>$$dis(a,r)+dis(r,R)\not&#x3D;dis(b,r)+dis(r,R)$$<br>得<br>$$dis(a,R)\not&#x3D;dis(b,R)$$<br>即 $a$、$b$ 到 $R$ 的距离不等。这与题目条件矛盾，所以命题成立。</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>既然结论 $1$ 成立，那么先从最简单的情况入手。</p><p>如图，在这一棵以 $1$ 为根的树中，在操作后，根节点 $1$ 到叶子的距离最小是几？</p><p><img src="/blog_assets/editorial_luogu_p1131_1.png" alt="图 1"></p><p>很明显的，这个值应该是所有叶子到根的所有距离的最大值。</p><p>那么对于每个节点都实行此原则，就结束了。</p><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;using uint = unsigned;using ll = long long;using ull = unsigned long long;using pii = pair&lt;int,int&gt;;using pll = pair&lt;ll,ll&gt;;#define int llint hd[500005&lt;&lt;1],nxt[500005&lt;&lt;1],to[500005&lt;&lt;1],we[500005&lt;&lt;1],et=0;inline void adde(int u,int v,int w) &#123; ++et,to[et]=v,we[et]=w,nxt[et]=hd[u],hd[u]=et; &#125;int n,s,ans,dp[500005];void dfs(int u,int fa) &#123;    int mx=0,tot=0;    for(int i=hd[u],v,t; v=to[i],t=we[i],i; i=nxt[i]) &#123;        if(v==fa) continue;        dfs(v,u);        if(dp[v]+t&gt;mx) &#123;            ans+=(dp[v]+t-mx)*tot;            mx=dp[v]+t;        &#125; else ans+=(mx-dp[v]-t);        ++tot;    &#125;    dp[u]=mx;&#125;signed main() &#123;    cin&gt;&gt;n&gt;&gt;s;    for(int i=1; i&lt;n; ++i) &#123;        int u,v,t;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;t;        adde(u,v,t); adde(v,u,t);    &#125;    dfs(s,0);    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> editorial </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/hello-world/"/>
      <url>/post/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
