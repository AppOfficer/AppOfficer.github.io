<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AOCode Round #5 Editorial</title>
      <link href="/post/aocr5-editorial/"/>
      <url>/post/aocr5-editorial/</url>
      
        <content type="html"><![CDATA[<h2 id="Contest-Problems"><a href="#Contest-Problems" class="headerlink" title="Contest Problems"></a>Contest Problems</h2><table><thead><tr><th align="center">No</th><th align="center">Title</th><th align="center">预估 Diff</th><th align="center">zxx 预估 Diff</th><th align="center">Diff</th></tr></thead><tbody><tr><td align="center">$A1$</td><td align="center"><a href="http://oj.oimaster.cf/contest/2/">The Triangle Print</a></td><td align="center">$\color</td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> editorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOCode Round #6 Editorial</title>
      <link href="/post/aocr6-editorial/"/>
      <url>/post/aocr6-editorial/</url>
      
        <content type="html"><![CDATA[<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><a href="#table-of-contents">Table of Contents</a></li><li><a href="#a---bash-game-bg">$A$ - Bash Game (BG)</a><ul><li><a href="#%E6%A0%87%E9%A2%98%E7%9A%84%E7%90%86%E8%A7%A3">标题的理解</a></li><li><a href="#%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88%E7%9A%84%E7%89%B9%E4%BE%8B">巴什博弈的特例</a></li><li><a href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88">一般的巴什博弈</a></li><li><a href="#%E5%AF%B9%E4%BA%8E%E6%9C%AC%E9%A2%98%E7%9A%84%E6%89%A9%E5%B1%95">对于本题的扩展</a></li></ul></li><li><a href="#c---flip-to-maximum-f2m">$C$ - Flip to Maximum (F2M)</a></li><li><a href="#d---tree-shadow-ts">$D$ - Tree Shadow (TS)</a><ul><li><a href="#%E5%9C%A8%E5%81%9A%E9%A2%98%E4%B9%8B%E5%89%8D%E7%9A%84%E5%8F%91%E7%8E%B0">在做题之前的发现</a></li><li><a href="#%E7%AE%80%E5%8D%95%E6%83%85%E5%86%B5--%E6%8E%A8%E5%85%AC%E5%BC%8F">简单情况 | 推公式</a></li><li><a href="#%E5%85%AC%E5%BC%8F%E7%9A%84%E5%8F%8D%E4%BE%8B">“公式”的反例</a></li><li><a href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%85%AC%E5%BC%8F">真正的公式</a></li></ul></li><li><a href="#e---array-counting-ac">$E$ - Array Counting (AC)</a></li><li><a href="#f---function-extreme-fex">$F$ - Function Extreme (FEx)</a></li></ul><h2 id="A-Bash-Game-BG"><a href="#A-Bash-Game-BG" class="headerlink" title="$A$ - Bash Game (BG)"></a>$A$ - Bash Game (BG)</h2><p><strong>这是本场比赛的第二签到题。</strong></p><p>如果你认真观看了题目中的视频，那么这题对于你<strong>一定是很简单的</strong>。</p><p><del>其实视频就是题解……</del></p><h3 id="标题的理解"><a href="#标题的理解" class="headerlink" title="标题的理解"></a>标题的理解</h3><p>标题 Bash Game，即巴什博弈，讲的是下面这样的一个博弈：</p><blockquote><p>有一堆 $n$ 个石子，两个人轮流取，一次最多取 $m$ 颗，谁先取完最后一颗谁赢。（更好的说法，直到谁不能取时谁就输了）</p></blockquote><p>这是一个公平组合游戏。由于这是签到题，本题解将不会具体描述 SG 函数 等<del>奇奇怪怪的</del>东西，有需要的读者可以上 <a href="http://oi-wiki.org/">OI Wiki</a> 自行查找。</p><h3 id="巴什博弈的特例"><a href="#巴什博弈的特例" class="headerlink" title="巴什博弈的特例"></a>巴什博弈的特例</h3><p>我们先不从一般的说起。先来举个栗子：现在 $n&#x3D;19,m&#x3D;5$，如果两个人都使用最优策略，谁会赢？</p><p>很明显先手必胜。先手只要拿 $1$ 个，以后如果对方拿 $a$ 个，先手就拿 $6-a$ 个，这样一定能先拿到最后一个。</p><p>给一个简易的示例：</p><table><thead><tr><th align="right">Who</th><th align="right">1</th><th align="right">2</th><th align="right">3</th><th align="right">4</th></tr></thead><tbody><tr><td align="right">先手</td><td align="right">1</td><td align="right">4</td><td align="right">3</td><td align="right">5</td></tr><tr><td align="right">后手</td><td align="right">2</td><td align="right">3</td><td align="right">1</td><td align="right"></td></tr><tr><td align="right">剩余</td><td align="right">16</td><td align="right">9</td><td align="right">5</td><td align="right">0</td></tr></tbody></table><p>扩展到一般的上面：</p><h3 id="一般的巴什博弈"><a href="#一般的巴什博弈" class="headerlink" title="一般的巴什博弈"></a>一般的巴什博弈</h3><p>下面的对于一般的巴什博弈的扩展：</p><blockquote><p>对于一场巴什博弈，有 $n$ 个石子，一次最多取 $m$ 颗，那么先手必胜，仅当 $n\not\equiv 0\pmod{m+1}$。</p><p>证明：</p><p>当 $n&#x3D;0$ 时，无石子，此时先手必输。<br>当 $n&#x3D;1,2,3,\cdots,m$ 时，先手只要拿一次即可取走所有石子，先手必胜。<br>当 $n&#x3D;m+1$ 时，先手无论取多少石子，都会将局面推到对方的 $n&#x3D;1,2,3,\cdots,m$ 的局面，此时先手必输。<br>……</p><p>以此类推，当 $n\equiv0\pmod{n+1}$ 时，先手必败；反之先手必胜。</p></blockquote><h3 id="对于本题的扩展"><a href="#对于本题的扩展" class="headerlink" title="对于本题的扩展"></a>对于本题的扩展</h3><p>对于本题，限制 $m$ 是可以改变的。</p><p>此时，我们的目标就是，在每一次取子后，都要保证轮到对方取子时，对方在当时限制下处于必败局面（即“后手必败”）。</p><p>若在限制 $m$ 下必败，则此时石子总数 $n$ 满足 $(m+1)|n$。</p><p>那么，我们只要选出一个限制，然后取走余数个石子即可。</p><p>重复以上操作，你就能通过本题了。</p><h2 id="C-Flip-to-Maximum-F2M"><a href="#C-Flip-to-Maximum-F2M" class="headerlink" title="$C$ - Flip to Maximum (F2M)"></a>$C$ - Flip to Maximum (F2M)</h2><p>这是<strong>本场比赛的签到题</strong>。做不出本题是不应该的。</p><p>容易发现，当 $x$ 末尾是 <code>1</code> 时，可以通过永远取 $[L,R]&#x3D;[x.size,x.size]$ 来任意修改 $s$。</p><p>扩展一下，只要取 $x$ 最后一个 <code>1</code> 及之后的所有 <code>0</code>（设为 $y$ 个）即可任意修改 $s$ 除了后 $y$ 位以外的所有字符。</p><p>于是题目便很简单。再简单判一下有无符号即可。注意不要忘了模 $1<del>224</del>845<del>820</del>132<del>755</del>647$。</p><h2 id="D-Tree-Shadow-TS"><a href="#D-Tree-Shadow-TS" class="headerlink" title="$D$ - Tree Shadow (TS)"></a>$D$ - Tree Shadow (TS)</h2><p>这是一道纯数学题。本题将会使用大量三角函数，请先自行了解三角函数的概念。</p><h3 id="在做题之前的发现"><a href="#在做题之前的发现" class="headerlink" title="在做题之前的发现"></a>在做题之前的发现</h3><p>在你开始打代码之前，先仔细阅读一下题面。你会发现，<strong>其实太阳光的不含最大角度（$\alpha$）即为所有道路中下坡幅度最大的角度。</strong> 当然还要转换一下。</p><p>那么，其实我们只要求 $x$ 就行了。怎么求呢？</p><h3 id="简单情况-推公式"><a href="#简单情况-推公式" class="headerlink" title="简单情况 | 推公式"></a>简单情况 | 推公式</h3><p>如图，当 $d_2&gt;0$ 时，将原来在斜坡上的影子映射到地平线上，得到 $newl_2&#x3D;l_2\cos d_2+l_2\sin d_2\cot\beta$，其中 $\beta&#x3D;180\degree-\alpha$.</p><p><a href="https://imgse.com/i/pC4TcTI"><img src="https://s1.ax1x.com/2023/07/14/pC4TcTI.png" alt="pC4TcTI.png"></a></p><p>再如图，可以得到，当 $d_2&lt;0$ 时，以上式子仍然成立.</p><p><a href="https://imgse.com/i/pC4T60A"><img src="https://s1.ax1x.com/2023/07/14/pC4T60A.png" alt="pC4T60A.png"></a></p><p>当 $d_2&#x3D;0$ 时：</p><p>$$<br>\begin{split}<br>newl_2&amp;&#x3D;l_2\cos d_2+l_2\sin d_2\cot\beta\<br>      &amp;&#x3D;l_2\cdot 1+l_2\cdot 0\cdot\cot\beta\<br>      &amp;&#x3D;l_2<br>\end{split}<br>$$</p><p>所以，不论 $d_2$ 的大小，总有 $newl_2&#x3D;l_2\cos d_2+l_2\sin d_2\cot\beta~(\beta&#x3D;180\degree-\alpha)$.</p><p>推导到所有 $d_i$，可求出：$newl_i&#x3D;l_i\cos d_i+l_i\sin d_i\cot\beta~(\beta&#x3D;180\degree-\alpha)$.</p><p>那么就可以求出 $\displaystyle x&#x3D;\left(\sum_{i&#x3D;1}^{n}newl_i\right)\tan\beta~(\beta&#x3D;180\degree-\alpha)$.</p><p>递推算出对于所有 $l_i$ 的 $newl_i$，累加后计算即可.</p><p>这个公式<strong>没有问题</strong>，但是只能获得 $70%$ 的分数。这是为什么呢？</p><h3 id="“公式”的反例"><a href="#“公式”的反例" class="headerlink" title="“公式”的反例"></a>“公式”的反例</h3><p>当没有 $d_i&lt;0$ 时，$\alpha&#x3D;180\degree$，那么 $\beta&#x3D;0\degree$，由于 $\tan 0\degree&#x3D;0$，这样无论如何，最后求出的 $x$ 都是 $0$。而很明显，当有上坡路时，在地平线以上的道路当 $x&#x3D;0$ 时必然无法被照到。也就是说，这个“公式”是错的。</p><p>那么如何解决呢？能够发现，这个“公式”只在没有下坡路时失效，而没有下坡路时最小树高 $x$ 即为整条路上最高点的高度（假设地平线高度为 $0$）。于是只要特判一下就好了。</p><p>这样，就可以通过全部测试点，获得 $100$ 分。</p><p>不过，无论如何，这样的特判终究不能覆盖所有情况。能否有一种适用全部情况的公式呢？</p><h3 id="真正的公式"><a href="#真正的公式" class="headerlink" title="真正的公式"></a>真正的公式</h3><p>对于每段路 $i$，我们重定义 $newl_i$，新定义 $height_i$，$needx_i$：</p><ul><li>$newl_i$ 为这段路<strong>垂直</strong>映射到地面后的长度；</li><li>$height_i$ 为这段路<strong>右端点</strong>的高度；</li><li>$needx_i$ 为树影投射到这段路<strong>右端点</strong>所需的树的<strong>最小高度</strong>。</li></ul><p>通过一系列计算，我们可以得出：（同样的，$\beta&#x3D;180\degree-\alpha$）</p><p>$$<br>\begin{split}<br>newl_i   &amp;&#x3D; l_i\cos d_i \<br>height_i &amp;&#x3D; height_{i-1}+l_i\sin d_i&#x3D;\sum_{j&#x3D;1}^{i}l_j\sin d_j \<br>needx_i  &amp;&#x3D; height_i+\left(\sum_{j&#x3D;1}^{i}newl_j\right)\tan\beta<br>\end{split}<br>$$</p><p>最后，再求出 $\displaystyle x&#x3D;\max_{i&#x3D;1}^{n}need_i$ 即可[^1]。</p><p><strong>这才是本题的正解。</strong> 它能够直接获得 $100$ 分，甚至还不必为 $\cot$ 的运算方法发愁。</p><p>[^1]: 注：其实求 $x$ 直接取 $need_n$ 即可。至于为什么，请自行思考。</p><h2 id="E-Array-Counting-AC"><a href="#E-Array-Counting-AC" class="headerlink" title="$E$ - Array Counting (AC)"></a>$E$ - Array Counting (AC)</h2><p>咕咕咕……</p><h2 id="F-Function-Extreme-FEx"><a href="#F-Function-Extreme-FEx" class="headerlink" title="$F$ - Function Extreme (FEx)"></a>$F$ - Function Extreme (FEx)</h2><p>又是一道数学题。<del>建议打个二三十分的模拟退火就走人。</del></p><p>题解先咕着。（主要是比较难写）</p>]]></content>
      
      
      <categories>
          
          <category> editorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> editorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI 名言</title>
      <link href="/post/well-known-OI-sayings/"/>
      <url>/post/well-known-OI-sayings/</url>
      
        <content type="html"><![CDATA[<h2 id="《OI-子》三章"><a href="#《OI-子》三章" class="headerlink" title="《OI 子》三章"></a>《OI 子》三章</h2><blockquote><p>《骗分榜一，暴力爆零》by 20210732ktq<br>正解不如暴力，暴力不如骗分。一道题目，两种做法，想而编之而WA。夫想而编之，必有得正解者矣，然而WA者，是正解不如暴力也。手非不酸也，码非不短也，部分分非不多也，暴力非不正确也，排名第二，是暴力不如骗分也。故曰，AC不以思路之深，暴力不以代码之短，首杀不以手速之快。骗分者榜一，暴力者爆零。爆零之至，老师骂之。榜一之至，全球膜之。以全球之所膜，攻教练之所骂，故OIer有不战，战必AK。</p></blockquote><blockquote><p>《水题不能淫》by 20210927chr<br>chr曰：“ktq，xcx岂不诚奆佬哉？骗分而OIers惧，正解而OI熄。”<br>xrz曰：“是焉得为奆佬乎？子未学OI乎？奆佬之冠也，zc命之，蒟蒻之冠也，ls命之，往送之CSP，戒之曰：‘往之CSP，必敬必戒，无违考规！’以骗为正者，蒟蒻之道也。做天下之难题，写天下之正解，AK天下之比赛。AK，与OIers由之；不AK，自己切题。水题不能淫，难题不能移，毒瘤不能屈，此之谓奆佬。”</p></blockquote><blockquote><p>《生于练习，死于退费》by 20211202lxy<br>轩发于范赵之中，Sai_t举于richup之间，澜译举于冰火之中，孔韬棋举于gen，项承煦举于florr，蒋亦霖举于ma，故天将降大任于是人也，必先苦其射飞，劳其破产，饿其王塔，空乏连击，行拂乱其所为，使其停止退费，曾益其所不会。<br>人恒错，然后能改；减于空，缩于时，而后过；骗于分，暴于力，而后涨。入则无暴力骗分，出则无AC过题者，人恒寄。然后知生于练习而死于退费也。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P1131 题解</title>
      <link href="/post/luogu-p1131-editorial/"/>
      <url>/post/luogu-p1131-editorial/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.luogu.com.cn/problem/P1131">传送门</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一棵 $n$ 个节点的以 $s$ 为根的树。每条树边都有一个长度。每次操作可以把一条树边的长度加 $1$。</p><p>问：至少操作多少次，可以使根节点到每个叶子节点的距离相等。</p><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论 $1$"></a>结论 $1$</h2><p>对于任意子树，其根节点到其每个叶子节点的距离相等。</p><blockquote><p><strong>证明</strong>：<br>反证法。<br>设对于根为 $R$ 的树的根为 $r$ 的某一子树，有两个叶子 $a$、$b$ 到 $r$ 的距离不等。<br>那么不妨设节点 $x$ 与 $y$ 间的距离为 $dis(x,y)$，则有<br>$$dis(a,r)\not&#x3D;dis(b,r)$$<br>所以<br>$$dis(a,r)+dis(r,R)\not&#x3D;dis(b,r)+dis(r,R)$$<br>得<br>$$dis(a,R)\not&#x3D;dis(b,R)$$<br>即 $a$、$b$ 到 $R$ 的距离不等。这与题目条件矛盾，所以命题成立。</p></blockquote><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>既然结论 $1$ 成立，那么先从最简单的情况入手。</p><p>如图，在这一棵以 $1$ 为根的树中，在操作后，根节点 $1$ 到叶子的距离最小是几？</p><p><img src="/blog_assets/editorial_luogu_p1131_1.png" alt="图 1"></p><p>很明显的，这个值应该是所有叶子到根的所有距离的最大值。</p><p>那么对于每个节点都实行此原则，就结束了。</p><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;using uint = unsigned;using ll = long long;using ull = unsigned long long;using pii = pair&lt;int,int&gt;;using pll = pair&lt;ll,ll&gt;;#define int llint hd[500005&lt;&lt;1],nxt[500005&lt;&lt;1],to[500005&lt;&lt;1],we[500005&lt;&lt;1],et=0;inline void adde(int u,int v,int w) &#123; ++et,to[et]=v,we[et]=w,nxt[et]=hd[u],hd[u]=et; &#125;int n,s,ans,dp[500005];void dfs(int u,int fa) &#123;    int mx=0,tot=0;    for(int i=hd[u],v,t; v=to[i],t=we[i],i; i=nxt[i]) &#123;        if(v==fa) continue;        dfs(v,u);        if(dp[v]+t&gt;mx) &#123;            ans+=(dp[v]+t-mx)*tot;            mx=dp[v]+t;        &#125; else ans+=(mx-dp[v]-t);        ++tot;    &#125;    dp[u]=mx;&#125;signed main() &#123;    cin&gt;&gt;n&gt;&gt;s;    for(int i=1; i&lt;n; ++i) &#123;        int u,v,t;        cin&gt;&gt;u&gt;&gt;v&gt;&gt;t;        adde(u,v,t); adde(v,u,t);    &#125;    dfs(s,0);    cout&lt;&lt;ans&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> editorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/hello-world/"/>
      <url>/post/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
