<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AOCode Round #5 Editorial | AOBlog</title><meta name="author" content="AppOfficer"><meta name="copyright" content="AppOfficer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Table of Contents Table of Contents $A1$ The Triangle Print $A2$ The Square Print 初步观察 推式子   $C$ Powers 2 $E$ Dates or No Dates? 解法   $F$ Date Number 解法   $G$ Index Equation 题意解释 解法   $H$ Coding for C">
<meta property="og:type" content="article">
<meta property="og:title" content="AOCode Round #5 Editorial">
<meta property="og:url" content="http://appofficer.github.io/post/aocr5-editorial/index.html">
<meta property="og:site_name" content="AOBlog">
<meta property="og:description" content="Table of Contents Table of Contents $A1$ The Triangle Print $A2$ The Square Print 初步观察 推式子   $C$ Powers 2 $E$ Dates or No Dates? 解法   $F$ Date Number 解法   $G$ Index Equation 题意解释 解法   $H$ Coding for C">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://appofficer.github.io/blog_assets/auther.jpg">
<meta property="article:published_time" content="2023-07-14T12:13:14.000Z">
<meta property="article:modified_time" content="2023-07-14T12:34:14.076Z">
<meta property="article:author" content="AppOfficer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://appofficer.github.io/blog_assets/auther.jpg"><link rel="shortcut icon" href="/blog_assets/auther.jpg"><link rel="canonical" href="http://appofficer.github.io/post/aocr5-editorial/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AOCode Round #5 Editorial',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-14 20:34:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog_assets/auther.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/blog_assets/ds01.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="AOBlog"><img class="site-icon" src="/blog_assets/auther.jpg"/><span class="site-name">AOBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AOCode Round #5 Editorial</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-14T12:13:14.000Z" title="发表于 2023-07-14 20:13:14">2023-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-14T12:34:14.076Z" title="更新于 2023-07-14 20:34:14">2023-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/editorial/">editorial</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AOCode Round #5 Editorial"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#a1-the-triangle-print">$A1$ The Triangle Print</a></li>
<li><a href="#a2-the-square-print">$A2$ The Square Print</a><ul>
<li><a href="#%E5%88%9D%E6%AD%A5%E8%A7%82%E5%AF%9F">初步观察</a></li>
<li><a href="#%E6%8E%A8%E5%BC%8F%E5%AD%90">推式子</a></li>
</ul>
</li>
<li><a href="#c-powers-2">$C$ Powers 2</a></li>
<li><a href="#e-dates-or-no-dates">$E$ Dates or No Dates?</a><ul>
<li><a href="#%E8%A7%A3%E6%B3%95">解法</a></li>
</ul>
</li>
<li><a href="#f-date-number">$F$ Date Number</a><ul>
<li><a href="#%E8%A7%A3%E6%B3%95-1">解法</a></li>
</ul>
</li>
<li><a href="#g-index-equation">$G$ Index Equation</a><ul>
<li><a href="#%E9%A2%98%E6%84%8F%E8%A7%A3%E9%87%8A">题意解释</a></li>
<li><a href="#%E8%A7%A3%E6%B3%95-2">解法</a></li>
</ul>
</li>
<li><a href="#h-coding-for-codes">$H$ Coding for Codes</a><ul>
<li><a href="#std-%E5%81%9A%E6%B3%95"><code>std</code> 做法</a></li>
<li><a href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95">可能的另一种做法</a></li>
</ul>
</li>
<li><a href="#i-new-operation-defined">$I$ New Operation Defined</a><ul>
<li><a href="#fx-%E7%BB%93%E6%9E%9C%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7">$f(x)$ 结果的唯一性</a></li>
<li><a href="#fx-%E7%BB%93%E6%9E%9C%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F">$f(x)$ 结果的一般形式</a><ul>
<li><a href="#3-%E4%B8%AA%E8%B4%A8%E5%9B%A0%E6%95%B0">$3$ 个质因数</a></li>
<li><a href="#4-%E4%B8%AA%E8%B4%A8%E5%9B%A0%E6%95%B0">$4$ 个质因数</a></li>
<li><a href="#%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F">最后的一般形式</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%B3%95-3">解法</a></li>
</ul>
</li>
<li><a href="#ex-equation-solver">$Ex$ Equation Solver</a></li>
</ul>
<h2 id="A1-The-Triangle-Print"><a href="#A1-The-Triangle-Print" class="headerlink" title="$A1$ The Triangle Print"></a>$A1$ The Triangle Print</h2><p>$A1$ 过于简单，被 zxx 等 <code>dalao</code> 无限吐槽，你看看，这题是有多水。</p>
<h2 id="A2-The-Square-Print"><a href="#A2-The-Square-Print" class="headerlink" title="$A2$ The Square Print"></a>$A2$ The Square Print</h2><p>对于此题的难度，zxx 与 AOCR#5 出题人们 有很大的分歧。。。</p>
<p>本题与 $A1$ 一样，也是图形打印，但是稍微难一点。</p>
<h3 id="初步观察"><a href="#初步观察" class="headerlink" title="初步观察"></a>初步观察</h3><p>让我们看一下样例。</p>
<pre><code class="plain">(0)
+
(1)
+-+
| |
+-+
(2)
+-+--+-+
| |  | |
+-+  +-+
|      |
+-+  +-+
| |  | |
+-+--+-+
(3)
+-+--+-+----+-+--+-+
| |  | |    | |  | |
+-+  +-+    +-+  +-+
|      |    |      |
|      |    |      |
+-+  +-+    +-+  +-+
| |  | |    | |  | |
+-+--+-+    +-+--+-+
|                  |
|                  |
|                  |
|                  |
+-+--+-+    +-+--+-+
| |  | |    | |  | |
+-+  +-+    +-+  +-+
|      |    |      |
|      |    |      |
+-+  +-+    +-+  +-+
| |  | |    | |  | |
+-+--+-+----+-+--+-+
</code></pre>
<p>能够看出，对于第 $i$ 幅图，它的四个角上为第 $i-1$ 幅图，并在边上用 $2^{i-1}$ 个 <code>-</code> 或 <code>|</code> 连接。</p>
<p>这样，我们便能输入 $n$ 后，预处理递推出第 $i$ 幅图的边长（$i\in[1,n]\land i\in\Bbb{Z}$）。那么也就可以（当 $n&lt;10$ 时）递归画图了。</p>
<p>但是此时只能接受 $1\le n\le 10^5$ 的数据范围，也就是说，只能通过前 $12$ 个测试点，获得 $34$ 分的“好成绩”。要怎么使程序接受 $1\le n \le 10^9$，甚至 $1\le n\le 10^{18}$ 的数据范围呢？</p>
<p>左思右想，只有推式子了。</p>
<h3 id="推式子"><a href="#推式子" class="headerlink" title="推式子"></a>推式子</h3><p>定义 $f(n)$ 为第 $n$ 个正方形的边长，则有 $f(0)&#x3D;1,f(n)&#x3D;2f(n-1)+2^{n-1}$。</p>
<p>那么有：</p>
<p>$$\begin{split}<br>f(n)&amp;&#x3D;2f(n-1)+2^{n-1}\<br>    &amp;&#x3D;2(2f(n-2)+2^{n-2})+2^{n-1}\<br>    &amp;&#x3D;2(2(2f(n-3)+2^{n-3})+2^{n-2})+2^{n-1}\<br>    &amp;&#x3D;\cdots\<br>    &amp;&#x3D;\underbrace{2(2(2(\cdots2(2(2}<em>{n}(1)+\underbrace{2^0)+2^1)\cdots)+2^{n-3})+2^{n-2})+2^{n-1}}</em>{n}\<br>    &amp;&#x3D;2^n+\underbrace{2^{n-1}\cdot2^0+2^{n-2}\cdot2^1+\cdots+2^2\cdot2^{n-3}+2^{1}\cdot2^{n-2}+2^{n-1}}_{n}\<br>    &amp;&#x3D;2^n+n\cdot2^{n-1}<br>\end{split}$$</p>
<p>这样，一个简单的快速幂就搞定了！</p>
<p>能够接受 $1\le n\le 10^{18}$ 的数据范围，获得 $100$ 分！</p>
<p>上代码：（<code>std</code> 总用时约 $80ms$ — $20$ test cases）</p>
<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cctype&gt; // isdigit
#include &lt;cstring&gt; // memset

using namespace std;

#define div2(n) ((n)&gt;&gt;1)
#define int long long

const int mod=998244353;

int bpow(int x, int e) &#123;
    if(e==0) return 1;
    if(e==1) return x;
    int res=bpow(x,div2(e));
    res=res*res%mod;
    if(e&amp;1) res=res*x%mod;
    return res;
&#125;

int f(int x) &#123; return (bpow(2,x)+x%mod*bpow(2,x-1)%mod)%mod; &#125;

char mp[3005][3005];
void generate(int sx, int sy, int glen, int plen) &#123;
    if(plen==1) &#123;
        mp[sx][sy] = mp[sx][sy+2] = mp[sx+2][sy] = mp[sx+2][sy+2] = &#39;+&#39;;
        mp[sx][sy+1] = mp[sx+2][sy+1] = &#39;-&#39;;
        mp[sx+1][sy] = mp[sx+1][sy+2] = &#39;|&#39;;
        return;
    &#125;
    generate(sx, sy,
             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,
             plen-1);
    generate(sx+f(plen-1)+bpow(2,plen-1), sy,
             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,
             plen-1);
    generate(sx, sy+f(plen-1)+bpow(2,plen-1),
             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,
             plen-1);
    generate(sx+f(plen-1)+bpow(2,plen-1), sy+f(plen-1)+bpow(2,plen-1),
             (glen-bpow(2,plen-1))&gt;&gt;1 /* or f(plen-1) */,
             plen-1);
    for(int i = f(plen-1); i &lt; f(plen-1) + bpow(2,plen-1); ++i)&#123;
        mp[sx][sy+i] = mp[sx+glen-1][sy+i] = &#39;-&#39;;
        mp[sx+i][sy] = mp[sx+i][sy+glen-1] = &#39;|&#39;;
    &#125;
&#125;

inline int read() &#123;
    int res=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();
    return res;
&#125;

char __buf[5000000];

signed main() &#123;
    int n=read();
    setvbuf(stdout, __buf, _IOFBF, sizeof __buf);
    if(!n) return printf(&quot;1\n+\n&quot;), 0;
    printf(&quot;%lld\n&quot;, f(n));
    if(n&lt;=9 /* 1*2^9+9*2^8=2816 */) &#123;
        int l=f(n);
        for(int i=0; i&lt;l; ++i)
            for(int j=0; j&lt;l; ++j) mp[i][j]=&#39; &#39;;
        generate(0, 0, l, n); // generate!
        for(int i=0; i&lt;l; ++i) &#123;
            for(int j=0; j&lt;l; ++j)
                putchar(mp[i][j]);
            putchar(&#39;\n&#39;);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="C-Powers-2"><a href="#C-Powers-2" class="headerlink" title="$C$ Powers 2"></a>$C$ Powers 2</h2><p>此题为 AOCR #5 签到题。</p>
<p>具体详见 <a target="_blank" rel="noopener" href="http://oj.oimaster.cf/problem/14">KYCode Round #6 B - Powers</a>。</p>
<p><del>特别鸣谢：piggy123</del></p>
<p><a target="_blank" rel="noopener" href="http://oj.oimaster.cf/submission/374">上代码：（<code>std</code> 总用时约 $35ms$ — $20$ test cases）</a></p>
<h2 id="E-Dates-or-No-Dates"><a href="#E-Dates-or-No-Dates" class="headerlink" title="$E$ Dates or No Dates?"></a>$E$ Dates or No Dates?</h2><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>离散化+差分。</p>
<p>首先将 $L_i&#x2F;R_i&#x2F;l_i&#x2F;r_i$ 合并后进行离散化处理。（注意，一定要合并！）</p>
<p>接着开两个差分数组 <code>c1</code> 和 <code>c2</code>，一个存 $L_i&#x2F;R_i$，一个存 $l_i&#x2F;r_i$。</p>
<p>$L_i&#x2F;R_i$ 直接对应存：<code>++c1[L[i]],--c1[R[i]]</code>；</p>
<p>$l_i&#x2F;r_i$ 则比较复杂：</p>
<ul>
<li><code>forall i in [0,m): ++c2[r[i]],--c2[l[i+1]]</code>；</li>
<li><code>++c2[r[m]]</code>。</li>
</ul>
<p>如此，然后遍历整个数组，计算即可。</p>
<p>上代码：（<code>std</code> 总用时约 $350ms$ — $20$ test cases）</p>
<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cctype&gt; // isdigit
#include &lt;algorithm&gt;
using namespace std;

int n, m, len, res = 0;
int L[100005], R[100005];
int l[100005], r[100005];
int allnum[400020];
int c1[400020], c2[400020], sum1, sum2, tmc;

inline int read() &#123;
    int res=0; // no negative values
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();
    return res;
&#125;

char __buf[5000000];

signed main() &#123;
    setvbuf(stdout, __buf, _IOFBF, sizeof __buf);

    n=read();
    for(int i = 1; i &lt;= n; ++i) &#123;
        L[i]=read(), R[i]=read();
        allnum[i*2-1] = L[i];
        allnum[i*2] = R[i];
    &#125;
    m=read();
    for(int i = 1; i &lt;= m; ++i) &#123;
        l[i]=read(), r[i]=read();
        allnum[n*2+i*2-1] = l[i];
        allnum[n*2+i*2] = r[i];
    &#125;

    sort(allnum+1, allnum+n*2+m*2+1);
    len = unique(allnum+1, allnum+n*2+m*2+1)-allnum-1;

    for(int i = 1; i &lt;= n; ++i) &#123;
        L[i] = lower_bound(allnum+1, allnum+len+1, L[i])-allnum;
        R[i] = lower_bound(allnum+1, allnum+len+1, R[i])-allnum;
        ++c1[L[i]];
        --c1[R[i]];
    &#125;

    ++c2[0];
    for(int i = 1; i &lt;= m; ++i) &#123;
        l[i] = lower_bound(allnum+1, allnum+len+1, l[i])-allnum;
        r[i] = lower_bound(allnum+1, allnum+len+1, r[i])-allnum;
        --c2[l[i]];
        ++c2[r[i]];
    &#125;
    --c2[len];

    sum1=sum2=tmc=0;
    for(int i = 0; i &lt;= len; ++i) &#123;
        sum1+=c1[i];
        sum2+=c2[i];
        if(sum1 &amp;&amp; sum2) &#123;
            tmc += (allnum[i+1]-allnum[i]);
        &#125; else &#123;
            res = max(res, tmc);
            tmc = 0;
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, res);
    return 0;
&#125;
</code></pre>
<h2 id="F-Date-Number"><a href="#F-Date-Number" class="headerlink" title="$F$ Date Number"></a>$F$ Date Number</h2><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>Trie 半模板题。（或者：01Trie，zxx 说这不是 Trie？）</p>
<p>Trie 是一棵字典树，在这棵树上可以方便地判断前缀和。</p>
<p>对于本题，我们可以把整数看做是一个二进制串，把这个串像字符串一样插入 Trie。</p>
<p>这时，Trie 类似一个二叉树，一个节点只有两个子节点，通向它们的边分别是 <code>0</code> 和 <code>1</code>。</p>
<p>为了不重复地查询，我们可以在插入一个数前先查询目前这个数与其他数 $\oplus(\operatorname{xor})$ 的最大值。</p>
<p>如何查询？</p>
<ul>
<li>首先，将数插入 Trie 时，我们规定：从高位到低位依次插入（即，二进制串高位在前）；</li>
<li>然后，查询时，从最高位开始：<ul>
<li><code>(1)</code> 如果在这一位上，有与当前位不同的一条边（即此边上的 $0&#x2F;1$ 值 $\oplus$ 当前位后为 $1$），选择这条边，跳至 <code>(3)</code>；否则继续至 <code>(2)</code>。</li>
<li><code>(2)</code> 选择与当前位相同的边，然后跳至 <code>(3)</code>。</li>
<li><code>(3)</code> 进入下一位的查询，跳至 <code>(1)</code>。若已是最后一位，则退出，返回一路上所有边连起来后的值。</li>
</ul>
</li>
</ul>
<p>这样，一边读入，答案就出来了。时间复杂度 $\mathcal{O}(n\log2^{32})&#x3D;\mathcal{O}(32n)$。</p>
<p>上代码：（<code>std</code> 总用时约 $1100ms$ — $20$ test cases）</p>
<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#include &lt;tuple&gt;
using namespace std;

using uint = unsigned;
#define int uint

int n, q, a[100005];
int tot, trie[100005&lt;&lt;5][2];

void trie_init() &#123;
    memset(trie, 0, sizeof trie);
    tot=1;
&#125;
void trie_ins(int p) &#123;
    int rt = 1;
    for(int i=(1&lt;&lt;31); i&gt;0; i&gt;&gt;=1) &#123;
        int q = (p&amp;i)?1:0;
        if(trie[rt][q]==0) trie[rt][q]=++tot;
        rt = trie[rt][q];
    &#125;
&#125;
pair&lt;int,int&gt; trie_qry(int x) &#123;
    int rt=1, ans1=0, ans2=0;
    for(int i=(1&lt;&lt;31); i&gt;0; i&gt;&gt;=1) &#123;
        int q = (x&amp;i)?1:0;
        if(trie[rt][q^1]) &#123;
            ans1 = ans1&lt;&lt;1|(q^1);
            ans2 = ans2&lt;&lt;1|1;
            rt = trie[rt][q^1];
        &#125; else &#123;
            ans1 = ans1&lt;&lt;1|q;
            ans2 = ans2&lt;&lt;1;
            rt = trie[rt][q];
        &#125;
    &#125;
    return &#123;ans1,ans2&#125;;
&#125;

char __buf[5000000];

signed main() &#123;
    setvbuf(stdout, __buf, _IOFBF, sizeof __buf);
    scanf(&quot;%u&quot;, &amp;n);
    trie_init();
    for(int i = 0; i &lt; n; ++i) &#123;
        scanf(&quot;%u&quot;, a+i);
        trie_ins(a[i]);
    &#125;
    scanf(&quot;%u&quot;, &amp;q);
    while(q--) &#123;
        int x;
        scanf(&quot;%u&quot;, &amp;x);
        int a, b;
        tie(a,b) = trie_qry(x);
        printf(&quot;%u %u\n&quot;, a, b);
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="G-Index-Equation"><a href="#G-Index-Equation" class="headerlink" title="$G$ Index Equation"></a>$G$ Index Equation</h2><h3 id="题意解释"><a href="#题意解释" class="headerlink" title="题意解释"></a>题意解释</h3><p>这题大家读题应该很困难吧。。。为了安慰大家脆弱的心灵，这里给出题意解释。</p>
<blockquote>
<p>对于任意两个整数 $x$、$y$（$x&gt;y$），一定能够找出一个<strong>实数</strong> $d$，使得 $(x)<em>{10}&#x3D;(y)</em>{d}$（即 $10$ 进制下的 $x$ 等于 $d$ 进制下的 $y$）。给出 $x$、$y$，找出这个<strong>实数</strong> $d$，保留 $4$ 位小数。</p>
</blockquote>
<p>注意，上面明确说明 <strong>$d$ 是实数</strong>！也就是说，$d$ 不一定是整数。<strong>也就是说，本题不能进行枚举。</strong></p>
<p>不枚举怎么办？</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>题目中说明 $x$、$y$ 不超过 $4$ 位。让我们推一推式子：</p>
<p>设 $x&#x3D;\overline{a_1a_2a_3a_4}$，$y&#x3D;\overline{b_1b_2b_3b_4}$。</p>
<p>那么根据进制的定义，有 $10^3a_1+10^2a_2+10a_3+a_4&#x3D;d^3b_1+d^2b_2+db_3+b_4$。</p>
<p>整理一下，得 $b_1d^3+b_2d^2+b_3d&#x3D;x-b_4$。</p>
<p>那么问题就成了求这个关于 $d$ 的方程的一个<strong>正实数</strong>解。（进制默认为正数）</p>
<p><del>对于任何一元 $n$ 次方程，未知数在第一象限上都是单调的。</del>（左边的话十分错误）</p>
<p>对于任何 $n\ge 1$ 的指数函数，函数在第一象限全部单调上升。故它们的和函数也在第一象限单调上升，值具有单调性，二分正确。</p>
<p>那么二分 $d$ 就行了。<strong>注意精度。</strong></p>
<p>时间复杂度：$\mathcal{O}(\log x)$。</p>
<p>上代码：（<code>std</code> 总用时约 $30ms$ — $20$ test cases）</p>
<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
using namespace std;

const double eps = 1e-6;

int x, y;
int yy[10], len;

void inityy() &#123;
    yy[1] = y / 1000;
    yy[2] = y / 100 % 10;
    yy[3] = y / 10 % 10;
    yy[4] = y % 10;
&#125;

double f(double x) &#123;
    return 1.0*yy[1]*x*x*x + 1.0*yy[2]*x*x + 1.0*yy[3]*x + 1.0*yy[4];
&#125;

inline int read() &#123;
    int res=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();
    return res;
&#125;

signed main() &#123;
    x=read(),y=read();
    if(y&lt;10) printf(&quot;-1\n&quot;);
    else &#123;
        inityy();
        double l = 0.0, r = max(x, y);
        while(fabs(l-r)&gt;eps) &#123;
            double mid = (l+r)/2.0;
            double p = f(mid);
            if(p-x&gt;eps) r = mid;
            else l = mid;
        &#125;
        printf(&quot;%.5f\n&quot;, l);
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="H-Coding-for-Codes"><a href="#H-Coding-for-Codes" class="headerlink" title="$H$ Coding for Codes"></a>$H$ Coding for Codes</h2><p>本题应有两种做法。由于<del>时间</del>技术原因，这里仅讲解一种做法。</p>
<h3 id="std-做法"><a href="#std-做法" class="headerlink" title="std 做法"></a><code>std</code> 做法</h3><p>由题目我们可以发现，在本题中，$x$ 越小，$g$ 越大；$x$ 越大，$g$ 越小。因此，$x$ 满足单调性。</p>
<p>那么，既然要求 $x$ 的个数，就可以求出 $x$ 的最小值 $x_{max}$ 和最大值 $x_{min}$，然后输出 $x_{max}-x_{min}+1$ 即可。</p>
<p>至于 $x_{min}$ 和 $x_{max}$，既然 $x$ 单调，就可以用二分解答。</p>
<p>时间复杂度 $\mathcal{O}(t\log x)$。</p>
<p>上代码：（<code>std</code> 总用时约 $40ms$ — $10$ test cases）</p>
<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cctype&gt;
using namespace std;

#define div2(n) ((n)&gt;&gt;1)

long long t;
long long a, b, c, g;

long long check(long long p) &#123;
    for(long long i = 0; i &lt; g; ++i) &#123;
        if(p&gt;c) return i;
        p=p*a+b;
    &#125;
    if(p&gt;c) return g;
    return p;
&#125;

inline long long read() &#123;
    long long res=0;
    char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48),c=getchar();
    return res;
&#125;

signed main() &#123;
    t=read();
    while(t--) &#123;
        a=read(),b=read(),c=read(),g=read();
        long long ansl, ansr;

        if(g==0) &#123;
            printf(&quot;%llu\n&quot;, (unsigned long long)(-1)-(unsigned long long)c);
            continue;
        &#125;

        // CHECK MINIMUM
        long long l=0, r=c, x;
        while(l&lt;r) &#123;
            x = div2(l+r);
            long long f = check(x);
            if(f&lt;=g) r = x;
            else l = x+1;
        &#125;
        ansl = r;
        if(check(ansl)!=g) &#123;
            printf(&quot;0\n&quot;);
            continue;
        &#125;

        // CHECK MAXIMUM
        l=0, r=c;
        while(l&lt;r) &#123;
            x = div2(l+r+1);
            long long f = check(x);
            if(f&lt;g) r = x-1;
            else l = x;
        &#125;
        ansr = l;
        if(check(ansr)!=g) &#123;
            printf(&quot;0\n&quot;);
            continue;
        &#125;

        printf(&quot;%lld\n&quot;, ansr-ansl+1);
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="可能的另一种做法"><a href="#可能的另一种做法" class="headerlink" title="可能的另一种做法"></a>可能的另一种做法</h3><p>既然 $g$ 已知，那么就可以用已知的 $g$，倒推出 $x_{max}$ 和 $x_{min}$，然后计算即可。</p>
<p>这可能是选手的第一想法。</p>
<p>Authors 因时间原因，没有深入思考这个问题，但是，我们认为这个方法有以下几个特点：</p>
<ul>
<li>复杂。倒推因为有除法，式子很难推，推的过程很复杂；即使推出来，式子也有可能很复杂。</li>
<li>但是，这个方法一定（Authors 预测）比 <code>std</code> 做法快（即使是常数上的）。</li>
</ul>
<h2 id="I-New-Operation-Defined"><a href="#I-New-Operation-Defined" class="headerlink" title="$I$ New Operation Defined"></a>$I$ New Operation Defined</h2><h3 id="f-x-结果的唯一性"><a href="#f-x-结果的唯一性" class="headerlink" title="$f(x)$ 结果的唯一性"></a>$f(x)$ 结果的唯一性</h3><p>让我们先回顾一下题目中 $f(…)$ 的定义。</p>
<ul>
<li>若 $x$ 是质数，则 $f(x)&#x3D;1$；</li>
<li>若有两个大于 $1$ 的整数 $a,b$，则 $f(ab)&#x3D;bf(a)+af(b)$。</li>
</ul>
<p>有人会疑惑：这样对于同一个 $f(x)$，不同计算方法是不是结果就不一样呢？其实不然。</p>
<p>假设 $x&#x3D;30$，则 $f(x)&#x3D;f(30)$ 有以下几种计算方法，仔细思考一下会发现是一样的：</p>
<p>$$\begin{split}<br>(1):f(30)&amp;&#x3D;f(2\times15)\<br>         &amp;&#x3D;15f(2)+2f(15)\<br>         &amp;&#x3D;15+2f(3\times5)\<br>         &amp;&#x3D;15+2(5f(3)+3f(5))\<br>         &amp;&#x3D;15+2(5+3)\<br>         &amp;&#x3D;15+2\times8\<br>         &amp;&#x3D;15+16\<br>         &amp;&#x3D;31\<br>(2):f(30)&amp;&#x3D;f(3\times10)\<br>         &amp;&#x3D;10f(3)+3f(10)\<br>         &amp;&#x3D;10+3f(\times5)\<br>         &amp;&#x3D;10+3(5f(2)+2f(5))\<br>         &amp;&#x3D;10+3(5+2)\<br>         &amp;&#x3D;10+3\times7\<br>         &amp;&#x3D;10+21\<br>         &amp;&#x3D;31\<br>(3):f(30)&amp;&#x3D;f(5\times6)\<br>         &amp;&#x3D;6f(5)+5f(6)\<br>         &amp;&#x3D;6+5f(2\times3)\<br>         &amp;&#x3D;6+5(3f(2)+2f(3))\<br>         &amp;&#x3D;6+5(3+2)\<br>         &amp;&#x3D;6+5\times5\<br>         &amp;&#x3D;6+25\<br>         &amp;&#x3D;31<br>\end{split}$$</p>
<p>如上，我们能够发现无论怎么计算，结果都一样。</p>
<p>并且我们发现，$f(x)$ 的结果只与 $x$ 的约数有关，那么就可以枚举 $x$ 的所有约数，向下递归得出答案。</p>
<p>这是一个可行方案，时间复杂度 $\mathcal{O}(kn^2)$。（$k$ 是一次高精乘&#x2F;除法的复杂度）</p>
<h3 id="f-x-结果的一般形式"><a href="#f-x-结果的一般形式" class="headerlink" title="$f(x)$ 结果的一般形式"></a>$f(x)$ 结果的一般形式</h3><p>上面所说的可行方案明显无法通过时间限制，因为 $1\le n\le 2000$，而 $k$ 又能达到 $6000$ 级别，$\mathcal{O}(kn^2)&#x3D;\mathcal{O}(2.4\times10^{10})$，无法承受。</p>
<p>那么就得找出更简便的算法了。我们试着推出 $f(x)$ 的一般形式。</p>
<p>题目给出的是质因数分解，那我们就从质因数下手。</p>
<p>先从 $3$ 个质因数下手。</p>
<h4 id="3-个质因数"><a href="#3-个质因数" class="headerlink" title="$3$ 个质因数"></a>$3$ 个质因数</h4><p>设 $x&#x3D;a\times b\times c$，其中 ${a,b,c}$ 是质数。</p>
<p>那么</p>
<p>$$\begin{split}<br>f(x)&amp;&#x3D;bcf(a)+af(bc)\<br>    &amp;&#x3D;bc+a(cf(b)+bf(c))\<br>    &amp;&#x3D;bc+a(c+b)\<br>    &amp;&#x3D;ab+ac+bc<br>\end{split}$$</p>
<p>如果指数不止 $1$ 次？</p>
<p>设 $x&#x3D;a^e\times b^p\times c^g$，其中 ${a,b,c}$ 是质数，${e,p,g}\in\Bbb{Z}^+$。</p>
<p>那么</p>
<p>$$\begin{split}<br>f(x)&amp;&#x3D;f\left(\underbrace{a\times a\times\cdots\times a}<em>{e}\times\underbrace{b\times b\times\cdots\times b}</em>{p}\times \underbrace{c\times c\times\cdots\times c}<em>{g}\right)\<br>    &amp;&#x3D;a^{e-1}b^pc^gf(a)+af\left(\underbrace{a\times a\times\cdots\times a}</em>{e-1}\times\underbrace{b\times b\times\cdots\times b}<em>{p}\times \underbrace{c\times c\times\cdots\times c}</em>{g}\right)\<br>    &amp;&#x3D;\cdots\<br>    &amp;&#x3D;e\times a^{e-1}b^pc^gf(a)+p\times a^eb^{p-1}c^gf(b)+g\times a^eb^pc^{g-1}f(c)\<br>    &amp;&#x3D;ea^{e-1}b^pc^g+pa^eb^{p-1}c^g+ga^eb^pc^{g-1}<br>\end{split}$$</p>
<p>$4$ 个质因数呢？</p>
<h4 id="4-个质因数"><a href="#4-个质因数" class="headerlink" title="$4$ 个质因数"></a>$4$ 个质因数</h4><p>设 $x&#x3D;a\times b\times c\times d$，其中 $a,b,c,d$ 是质数。</p>
<p>那么（过程略）</p>
<p>$$\begin{split}<br>f(x)&amp;&#x3D;\cdots\<br>    &amp;&#x3D;bcdf(a)+acdf(b)+abdf(c)+abcf(d)\<br>    &amp;&#x3D;abc+abc+acd+bcd<br>\end{split}$$</p>
<p>指数 $&gt;1$ 的情况这里就不枚举了。。。（累死人）</p>
<h4 id="最后的一般形式"><a href="#最后的一般形式" class="headerlink" title="最后的一般形式"></a>最后的一般形式</h4><p>设 $x&#x3D;p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times\cdots\times p_m^{a_m}$，其中 ${p_1,p_2,p_3,\cdots,p_m}$ 都是质数，${a_1,a_2,a_3,\cdots,a_m}\in\Bbb{Z}^+$。</p>
<p>那么</p>
<p>$$\begin{split}<br>f(x)&amp;&#x3D;\cdots\<br>    &amp;&#x3D;\sum^{m}<em>{i&#x3D;1}\left[a_i\times\left(\prod^{i-1}</em>{j&#x3D;1}p_j^{a_j}\right)\times p_i^{a_i-1}\times\left(\prod^{m}<em>{j&#x3D;i+1}p_j^{a_j}\right)\right]\<br>    &amp;&#x3D;\sum^{m}</em>{i&#x3D;1}\left(a_i\cdot\frac{x}{p_i}\right)<br>\end{split}$$</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>由于题目中直接给出质因数分解式，我们省去了分解质因数的时间。</p>
<p>那么，根据上面的公式，我们有一种简单做法：（<code>python</code>）</p>
<pre><code class="python">n = int(input())
res = input()
a = [int(n) for n in res.split()]
mul = 1
for i in range(n):
    mul = mul*a[i]
res = 0
for i in range(n):
    res += (mul//a[i])
print(res)
</code></pre>
<p><del>（没错第一个过这题的 <code>std</code> 是 <code>python</code> 写的嘿嘿嘿但你们过不去）</del></p>
<p>那么 <code>C++</code> 程序也很简单，本题的 <code>Author</code> nfls_old_salty_fish 只写了约 $30$ 行：</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
//#include &lt;windows.h&gt;
using namespace std;
typedef int czy;
typedef long long xtk;
typedef double zly;
xtk p[6005],t[6005],a[6005],s[6005],n,ans[6005];
int main()&#123;
    //freopen(&quot;10.in&quot;,&quot;r&quot;,stdin);
    //freopen(&quot;10.out&quot;,&quot;w&quot;,stdout);
    xtk n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    p[1]=1;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=6000;j++)p[j]*=a[i];
        for(int j=1;j&lt;=6000;j++)p[j+1]+=p[j]/10,p[j]%=10;
    &#125;
    for(int i=1;i&lt;=n;i++)&#123;
        for(int j=1;j&lt;=6000;j++)t[j]=p[j];
        for(int j=6000;j&gt;0;j--)s[j]=t[j]/a[i],t[j]%=a[i],t[j-1]+=t[j]*10;
        for(int j=1;j&lt;=6000;j++)ans[j]+=s[j],ans[j+1]+=ans[j]/10,ans[j]%=10;
    &#125;
    bool f=0;
    for(int i=6000;i&gt;0;i--)&#123;
        if(ans[i])f=1;
        if(ans[i]||f)cout&lt;&lt;ans[i];
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="Ex-Equation-Solver"><a href="#Ex-Equation-Solver" class="headerlink" title="$Ex$ Equation Solver"></a>$Ex$ Equation Solver</h2><p>咕咕咕………………………………</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://appofficer.github.io">AppOfficer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://appofficer.github.io/post/aocr5-editorial/">http://appofficer.github.io/post/aocr5-editorial/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://appofficer.github.io" target="_blank">AOBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/aocr6-editorial/" title="AOCode Round #6 Editorial"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">AOCode Round #6 Editorial</div></div></a></div><div class="next-post pull-right"><a href="/post/well-known-OI-sayings/" title="OI 名言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OI 名言</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog_assets/auther.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">AppOfficer</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AppOfficer"><i class="fab fa-github"></i><span>Talk less. Smile more.</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">AOCode Editorials can be found here!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Table-of-Contents"><span class="toc-number">1.</span> <span class="toc-text">Table of Contents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A1-The-Triangle-Print"><span class="toc-number">2.</span> <span class="toc-text">$A1$ The Triangle Print</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A2-The-Square-Print"><span class="toc-number">3.</span> <span class="toc-text">$A2$ The Square Print</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%A7%82%E5%AF%9F"><span class="toc-number">3.1.</span> <span class="toc-text">初步观察</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%BC%8F%E5%AD%90"><span class="toc-number">3.2.</span> <span class="toc-text">推式子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Powers-2"><span class="toc-number">4.</span> <span class="toc-text">$C$ Powers 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-Dates-or-No-Dates"><span class="toc-number">5.</span> <span class="toc-text">$E$ Dates or No Dates?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#F-Date-Number"><span class="toc-number">6.</span> <span class="toc-text">$F$ Date Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-1"><span class="toc-number">6.1.</span> <span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G-Index-Equation"><span class="toc-number">7.</span> <span class="toc-text">$G$ Index Equation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F%E8%A7%A3%E9%87%8A"><span class="toc-number">7.1.</span> <span class="toc-text">题意解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-2"><span class="toc-number">7.2.</span> <span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H-Coding-for-Codes"><span class="toc-number">8.</span> <span class="toc-text">$H$ Coding for Codes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-%E5%81%9A%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">std 做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%81%9A%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">可能的另一种做法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-New-Operation-Defined"><span class="toc-number">9.</span> <span class="toc-text">$I$ New Operation Defined</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#f-x-%E7%BB%93%E6%9E%9C%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">9.1.</span> <span class="toc-text">$f(x)$ 结果的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f-x-%E7%BB%93%E6%9E%9C%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">$f(x)$ 结果的一般形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%AA%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">$3$ 个质因数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%AA%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">$4$ 个质因数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F"><span class="toc-number">9.2.3.</span> <span class="toc-text">最后的一般形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95-3"><span class="toc-number">9.3.</span> <span class="toc-text">解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ex-Equation-Solver"><span class="toc-number">10.</span> <span class="toc-text">$Ex$ Equation Solver</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/aocr6-editorial/" title="AOCode Round #6 Editorial">AOCode Round #6 Editorial</a><time datetime="2023-07-14T12:13:14.000Z" title="发表于 2023-07-14 20:13:14">2023-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/aocr5-editorial/" title="AOCode Round #5 Editorial">AOCode Round #5 Editorial</a><time datetime="2023-07-14T12:13:14.000Z" title="发表于 2023-07-14 20:13:14">2023-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/well-known-OI-sayings/" title="OI 名言">OI 名言</a><time datetime="2023-05-13T03:14:11.000Z" title="发表于 2023-05-13 11:14:11">2023-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/luogu-p1131-editorial/" title="洛谷 P1131 题解">洛谷 P1131 题解</a><time datetime="2023-05-11T14:11:27.000Z" title="发表于 2023-05-11 22:11:27">2023-05-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/hello-world/" title="Hello World">Hello World</a><time datetime="2023-05-06T14:33:43.172Z" title="发表于 2023-05-06 22:33:43">2023-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By AppOfficer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function getGiscusTheme (theme) {
  return theme === 'dark' ? 'dark' : 'light'
}

function loadGiscus () {
  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'AppOfficer/blogtalk',
    'data-repo-id': 'R_kgDOJiNHpw',
    'data-category-id': 'DIC_kwDOJiNHp84CWcNa',
    'data-mapping': 'pathname',
    'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme (theme) {
  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame')
    if (!iframe) return
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
  }

  sendMessage({
    setConfig: {
      theme: getGiscusTheme(theme)
    }
  });
}

btf.addModeChange('giscus', changeGiscusTheme)

if ('Giscus' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Talk,less,Smile,more" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>